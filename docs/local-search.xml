<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何实现一个websocket服务器</title>
    <link href="/2022/06/15/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAwebsocket%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/06/15/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAwebsocket%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="如何实现一个websocket服务器"><a href="#如何实现一个websocket服务器" class="headerlink" title="如何实现一个websocket服务器"></a>如何实现一个websocket服务器</h1><p>本文将就如何搭建一个<code>WebSocket</code>服务器做较为细致的说明，关于<code>WebSocket</code>的定义以及优缺点不在此做说明。废话不多说，咱们进入正题。</p><h2 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h2><p>客户端的实现利用<code>WebSocket</code>API很简单就能完成，难点主要在服务端，因为它与平常的<code>GET</code>或<code>POST</code>请求不一样。相同的是它们都基于http协议，不同的是<code>WebSocket</code>多了一些额外的请求头：<code>Upgrade</code>以及一些以<code>Sec-WebSocket</code>开头的，后者我们主要关注的是<code>Sec-WebSocket-Key</code>。</p><p>服务端接收到了该请求后，需要根据<code>Sec-WebSocket-Key</code>生成唯一的<code>Sec-WebSocket-Accept</code>头部返回给客户端，除此之外还有<code>Upgrade</code>和<code>Connection</code>，响应的状态码则是<code>101</code>。</p><p>关于<code>Sec-WebSocket-Accept</code>是如何生成的，首先需要拿到客户端的<code>Sec-WebSocket-Key</code>，并将它与<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>拼接得到一个新的字符串，再将该字符串通过<code>SHA-1</code>算法加密，最后将加密后的字符串再进行<code>Base64</code>编码即可得到。如果客户端发送的<code>Sec-WebSocket-Key</code>为<code>vEkgOIDVZcUj1Z+v5BnEnA==</code>，那么服务端响应的<code>Sec-WebSocket-Accept</code>应该为<code>i8L6RCkmdYEUXgBdVajZ9/nMg1U=</code>。</p><blockquote><p>在Node中进行<code>SHA-1</code>加密的算法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createHash &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;crypto&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sha1</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createHash</span>(<span class="hljs-string">&quot;sha1&quot;</span>).<span class="hljs-title function_">update</span>(data).<span class="hljs-title function_">digest</span>();<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h2><p>在连接建立成功之后，在客户端尝试向服务端发送数据，会发现服务端接收到的数据是乱码（如果以字符串形式打印的话），这是因为客户端将数据进行编码了，我们还需要解码才能拿到其中的数据。</p><h3 id="解码数据"><a href="#解码数据" class="headerlink" title="解码数据"></a>解码数据</h3><h3 id="第一个字节"><a href="#第一个字节" class="headerlink" title="第一个字节"></a>第一个字节</h3><ol><li><p>第1位为FIN码，表示是否为最后一帧数据；</p></li><li><p>第2-4位为RSV码，用于扩展，可以忽略；</p></li><li><p>第5-8位为操作码，能够表示的操作如下：</p><ul><li><p>0x0: 表示一个延续帧。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片</p></li><li><p>0x1: 表示这是一个文本帧</p></li><li><p>0x2: 表示这是一个二进制帧</p></li><li><p>0x3-0x7: 保留的操作码，暂时无意义</p></li><li><p>0x8: 表示连接被断开</p></li><li><p>0x9: 表示这是一个心跳请求(ping)</p></li><li><p>0xa: 表示这是一个心跳响应(pong)</p></li><li><p>0xb-0xf: 保留的操作码，暂时无意义</p></li></ul></li></ol><h3 id="第二个字节"><a href="#第二个字节" class="headerlink" title="第二个字节"></a>第二个字节</h3><ol><li><p>第1位为MASK码，表示是否使用掩码，客户端发送的数据帧必须使用掩码(1)，否则服务端应该主动断开连接，而服务端发送的数据帧不需要</p></li><li><p>第2-8位表示载荷长度，最大能够表示<code>0b1111111</code>，因而分几种情况：</p><ul><li><p>如果该部分数据小于十进制数字125，那么它就是有效载荷的长度</p></li><li><p>如果该部分数据等于十进制数字126，那么<strong>第3、第4个字节</strong>表示的数字即为有效载荷的长度</p></li><li><p>如果该部分数据等于十进制数字127，那么<strong>第3、第4、第5、第6个字节</strong>所表示的数字即为有效载荷的长度</p></li></ul></li></ol><p>在解码出MASK码和载荷长度之后，接下来的四个字节即为<code>Masking key</code>，它被用来解码真正的载荷数据，解码步骤为：遍历载荷数据，记当前遍历字节为<code>i</code>(从0开始)，将当前字节与<code>Masking key</code>的第<code>i % 4</code>个字节做异或运算<code>^</code></p><h3 id="解码算法"><a href="#解码算法" class="headerlink" title="解码算法"></a>解码算法</h3><p>下面的代码只做了文本帧数据的解码，二进制帧解码类似。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">client</span>(<span class="hljs-params">buffer</span>) &#123;<br>  <span class="hljs-comment">// 解读第一位 FIN 码</span><br>  <span class="hljs-keyword">const</span> firstByte = buffer.<span class="hljs-title function_">readUint8</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 或者buffer[0]</span><br>  <span class="hljs-keyword">if</span> ((firstByte &gt;&gt; <span class="hljs-number">7</span>) &amp; <span class="hljs-number">0b1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;解码数据：这是最后一个数据帧&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 解读操作码</span><br>  <span class="hljs-keyword">const</span> op = firstByte &amp; <span class="hljs-number">0b1111</span>;<br>  <span class="hljs-keyword">if</span> (op === <span class="hljs-number">0x8</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;解码数据：这是一个中断操作&quot;</span>);<br>    <span class="hljs-comment">// 中断连接操作码</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">end</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (op === <span class="hljs-number">0x1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;解码数据：这是一个文本帧&quot;</span>);<br>    <span class="hljs-comment">// 文本帧</span><br>    <span class="hljs-keyword">const</span> secondByte = buffer.<span class="hljs-title function_">readUInt8</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 检查是否有 MASK 码</span><br>    <span class="hljs-keyword">if</span> (!((secondByte &gt;&gt;&gt; <span class="hljs-number">7</span>) &amp; <span class="hljs-number">0x1</span>)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;解码数据：该数据帧有 MASK 码&quot;</span>);<br>    <span class="hljs-keyword">const</span> payloadLen = secondByte &amp; <span class="hljs-number">0b1111111</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;解码数据：payloadLen&quot;</span>, payloadLen);<br>    <span class="hljs-keyword">let</span> maskingKeyOffset = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> maskingKey;<br>    <span class="hljs-keyword">if</span> (payloadLen &lt;= <span class="hljs-number">125</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;解码数据：payloadLen 小于等于 125&quot;</span>);<br>      maskingKeyOffset += <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (payloadLen === <span class="hljs-number">126</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;解码数据：payloadLen 等于 126&quot;</span>);<br>      maskingKeyOffset += <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (payloadLen === <span class="hljs-number">127</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;解码数据：payloadLen 等于 127&quot;</span>);<br>      maskingKeyOffset += <span class="hljs-number">4</span>;<br>    &#125;<br>    maskingKey = buffer.<span class="hljs-title function_">slice</span>(maskingKeyOffset, maskingKeyOffset + <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">const</span> payload = buffer.<span class="hljs-title function_">slice</span>(maskingKeyOffset + <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">const</span> data = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = payload.<span class="hljs-property">byteLength</span>; i &lt; len; i++) &#123;<br>      data.<span class="hljs-title function_">push</span>(payload[i] ^ maskingKey[i % <span class="hljs-number">4</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(data).<span class="hljs-title function_">toString</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="服务端发送数据"><a href="#服务端发送数据" class="headerlink" title="服务端发送数据"></a>服务端发送数据</h3><p>服务端发送数据与解码的操作相似，只是不用添加掩码（Masking Key）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">server</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">let</span> buffer, firstByte;<br>  <span class="hljs-keyword">if</span> (!data) &#123;<br>    data = <span class="hljs-string">&quot;no data!&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">isBuffer</span>(data)) &#123;<br>    firstByte = <span class="hljs-number">0b10000010</span>; <span class="hljs-comment">// 最终帧 &amp; 二进制帧</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;加码数据：二进制数据&quot;</span>);<br>    buffer = data;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) &#123;<br>    firstByte = <span class="hljs-number">0b10000001</span>; <span class="hljs-comment">// 最终帧 &amp; 文本帧</span><br>    data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;加码数据：&quot;</span>, data);<br>    buffer = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(data);<br>  &#125;<br>  <span class="hljs-keyword">const</span> bufferLen = buffer.<span class="hljs-property">byteLength</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;加码数据：数据长度&quot;</span>, bufferLen);<br>  <span class="hljs-keyword">const</span> sendData = [];<br>  sendData.<span class="hljs-title function_">push</span>(firstByte);<br>  <span class="hljs-keyword">let</span> secondByte = <span class="hljs-number">0b00000000</span>; <span class="hljs-comment">// 没有掩码</span><br>  <span class="hljs-keyword">if</span> (bufferLen &lt;= <span class="hljs-number">125</span>) &#123;<br>    secondByte ^= bufferLen;<br>    sendData.<span class="hljs-title function_">push</span>(secondByte);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bufferLen &gt; <span class="hljs-number">0b1111101</span> &amp;&amp; bufferLen &lt; <span class="hljs-number">0b1111111111111111</span>) &#123;<br>    secondByte = <span class="hljs-number">0b1111110</span>;<br>    <span class="hljs-keyword">const</span> len = []; <span class="hljs-comment">// 用两个字节表示长度</span><br>    len.<span class="hljs-title function_">push</span>((bufferLen &gt;&gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0b11111111</span>);<br>    len.<span class="hljs-title function_">push</span>(bufferLen &amp; <span class="hljs-number">0b11111111</span>);<br>    sendData.<span class="hljs-title function_">push</span>(secondByte, ...len);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    secondByte = <span class="hljs-number">0b1111111</span>;<br>    <span class="hljs-keyword">const</span> len = []; <span class="hljs-comment">// 用四个字节表示长度</span><br>    len.<span class="hljs-title function_">push</span>((bufferLen &gt;&gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0b11111111</span>);<br>    len.<span class="hljs-title function_">push</span>((bufferLen &gt;&gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0b11111111</span>);<br>    len.<span class="hljs-title function_">push</span>((bufferLen &gt;&gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0b11111111</span>);<br>    len.<span class="hljs-title function_">push</span>(bufferLen &amp; <span class="hljs-number">0b11111111</span>);<br>    sendData.<span class="hljs-title function_">push</span>(secondByte, ...len);<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;加码完成：&quot;</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([...sendData, ...buffer]));<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([...sendData, ...buffer]);<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sha1</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createHash</span>(<span class="hljs-string">&quot;sha1&quot;</span>).<span class="hljs-title function_">update</span>(data).<span class="hljs-title function_">digest</span>();<br>&#125;<br><br>http<br>  .<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; method, url, headers &#125; = req;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(method, url);<br>    <span class="hljs-keyword">if</span> (url === <span class="hljs-string">&quot;/&quot;</span> &amp;&amp; method === <span class="hljs-string">&quot;GET&quot;</span>) &#123;<br>      res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>        <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;text/html&quot;</span>,<br>      &#125;);<br>      <span class="hljs-title function_">getFile</span>(<span class="hljs-string">&quot;./index.html&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">index</span>) =&gt;</span> &#123;<br>        res.<span class="hljs-title function_">end</span>(index);<br>      &#125;);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;not found&quot;</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;upgrade&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, socket, head</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span> !== <span class="hljs-string">&quot;/socket&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> socket.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;http/1.1 400 Bad Request&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">headers</span>[<span class="hljs-string">&quot;upgrade&quot;</span>] !== <span class="hljs-string">&quot;websocket&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> socket.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;HTTP/1.1 400 Bad Request&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 检查子协议</span><br>    <span class="hljs-keyword">const</span> subProtocol = req.<span class="hljs-property">headers</span>[<span class="hljs-string">&quot;sec-websocket-protocol&quot;</span>];<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;子协议&quot;</span>, subProtocol);<br>    <span class="hljs-keyword">if</span> (subProtocol &amp;&amp; subProtocol !== <span class="hljs-string">&quot;json&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> socket.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;HTTP/1.1 400 Bad Request&quot;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;server on upgrade&quot;</span>);<br>    <span class="hljs-comment">// 读取客户端提供的Sec-WebSocket-Key</span><br>    <span class="hljs-keyword">const</span> secWsKey = req.<span class="hljs-property">headers</span>[<span class="hljs-string">&quot;sec-websocket-key&quot;</span>];<br>    <span class="hljs-comment">// 使用SHA-1算法生成Sec-WebSocket-Accept</span><br>    <span class="hljs-keyword">const</span> hash = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<br>      <span class="hljs-title function_">sha1</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;secWsKey&#125;</span>258EAFA5-E914-47DA-95CA-C5AB0DC85B11`</span>)<br>    ).<span class="hljs-title function_">toString</span>(<span class="hljs-string">&quot;base64&quot;</span>);<br>    <span class="hljs-comment">// 设置HTTP响应头</span><br>    <span class="hljs-keyword">const</span> responseHeaders = [<br>      <span class="hljs-string">&quot;HTTP/1.1 101 WebSocket Protocol Handshake&quot;</span>,<br>      <span class="hljs-string">&quot;Upgrade: WebSocket&quot;</span>,<br>      <span class="hljs-string">&quot;Connection: Upgrade&quot;</span>,<br>      <span class="hljs-string">`Sec-WebSocket-Accept: <span class="hljs-subst">$&#123;hash&#125;</span>`</span>,<br>    ];<br>    <span class="hljs-keyword">if</span> (subProtocol) &#123;<br>      responseHeaders.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Sec-WebSocket-Protocol: json&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 返回握手请求的响应信息</span><br>    socket.<span class="hljs-title function_">write</span>(responseHeaders.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;\r\n&quot;</span>) + <span class="hljs-string">&quot;\r\n\r\n&quot;</span>);<br>    <span class="hljs-comment">// sockets.emit(&quot;add&quot;, socket);</span><br>    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ondata&quot;</span>, e);<br>      <span class="hljs-keyword">const</span> data = client.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, e);<br>      <span class="hljs-keyword">if</span> (socket.<span class="hljs-property">writable</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ondata&quot;</span>, data);<br>        <span class="hljs-keyword">const</span> send = &#123;<br>          <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<br>          <span class="hljs-attr">message</span>: data,<br>        &#125;;<br>        socket.<span class="hljs-title function_">write</span>(<span class="hljs-title function_">server</span>(send));<br>      &#125;<br>    &#125;);<br>    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;onclose&quot;</span>, e);<br>    &#125;);<br>    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;onerror&quot;</span>, err);<br>    &#125;);<br>  &#125;)<br>  .<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;\n\thttp://127.0.0.1:8888\n&quot;</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">编写 WebSocket 服务器 - Web API 接口参考 | MDN</a></p></li><li><p><a href="https://developer.51cto.com/article/622153.html">你不知道的 WebSocket</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
      <tag>WebSocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web Components</title>
    <link href="/2022/04/23/webComponents/"/>
    <url>/2022/04/23/webComponents/</url>
    
    <content type="html"><![CDATA[<h1 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h1><p>通过<code>Web Components</code>，我们可以封装一系列的自定义组件，并在其内部维护各自的状态和行为，就像<code>Vue</code>和<code>React</code>一样。</p><h2 id="如何创建一个自定义组件"><a href="#如何创建一个自定义组件" class="headerlink" title="如何创建一个自定义组件"></a>如何创建一个自定义组件</h2><p>这里有两种方式去定义一个自定义组件：</p><ul><li><p><strong>自主定制元素</strong>：独立元素; 它们不会从内置 HTML 元素继承。</p></li><li><p><strong>自定义内置元素</strong>：这些元素继承自 - 并扩展 - 内置 HTML 元素。</p></li></ul><h3 id="自主定制元素"><a href="#自主定制元素" class="headerlink" title="自主定制元素"></a>自主定制元素</h3><p>首先我们需要新建一个类，继承自<code>HTMLElement</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后只需要通过<code>customElements</code>API注册这个组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">customElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;my-component&quot;</span>, <span class="hljs-title class_">MyComponent</span>);<br></code></pre></td></tr></table></figure><p>接下来我们就可以在任何地方用使用这个组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;my-component&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="自定义内置元素"><a href="#自定义内置元素" class="headerlink" title="自定义内置元素"></a>自定义内置元素</h3><p>和自主定制元素类似，首先需要新建一个类，并继承自某个HTML元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLDivElement</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后注册该组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">customElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;my-component&quot;</span>, <span class="hljs-title class_">MyComponent</span>, &#123; <span class="hljs-attr">extends</span>: <span class="hljs-string">&quot;div&quot;</span> &#125;);<br></code></pre></td></tr></table></figure><p>与自主定制元素不同的是在这里我们需要明确指出继承的HTML元素类型<code>extends: div</code>，使用的方式也有所不同，只需要在原HTML标签上添加<code>is</code>属性指定自定义组件的名称即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">is</span>=<span class="hljs-string">&quot;my-component&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>, &#123; <span class="hljs-attr">is</span>: <span class="hljs-string">&quot;my-component&quot;</span> &#125;);<br></code></pre></td></tr></table></figure><p>这时我们的组件里面还没有任何的内容，接下来继续向其中添加一些自定义的内容。</p><h2 id="向组件添加内容"><a href="#向组件添加内容" class="headerlink" title="向组件添加内容"></a>向组件添加内容</h2><p>我们可以在自定义类的构造函数中向自定义组件添加一些内容。这里以自主定制元素为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">super</span>();<br>  <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br>  div.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">appendChild</span>(div);<br>&#125;<br></code></pre></td></tr></table></figure><p>不出意外的话，此时刷新页面就能看到组件中的内容了。这个例子很简单，但是到这里相信绝大多数的人已经能够实现一些比较复杂的功能组件了。接下来继续说明自定义组件的生命周期，没错就像其他的前端框架一样，它也拥有自己的生命周期，只不过比较少。</p><h2 id="自定义组件的生命周期"><a href="#自定义组件的生命周期" class="headerlink" title="自定义组件的生命周期"></a>自定义组件的生命周期</h2><p>这里首先介绍两个用的场景比较多的：<code>connectedCallback</code>和<code>disconnectedCallback</code>。</p><p>首先是<code>connectedCallback</code>，它将在元素首次被挂载到DOM后调用。</p><p>其次是<code>disconnectedCallback</code>，它将在元素从DOM卸载时调用。</p><p>在<code>Vue</code>或<code>React</code>的基础上，这两个生命周期钩子不难理解，应用的地方很多也很有道理。</p><p>除了这两个常用的生命周期钩子之外，还有<code>adoptedCallback</code>和<code>attributeChangedCallback</code>，前者将在元素被移动到新节点时调用，后者将在元素的属性增加、删除或改变时调用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components">Web Components | MDN</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CustomElementRegistry/define">CustomElementRegistry.define - Web API 接口参考 | MDN</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fetch详解</title>
    <link href="/2022/03/25/fetch%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/03/25/fetch%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="fetch详解"><a href="#fetch详解" class="headerlink" title="fetch详解"></a>fetch详解</h1><p><code>fetch</code>为一种新的获取网络资源的接口，它提供了相比与<code>XMLHTTPRequest</code>更为丰富灵活的功能。Fetch 提供了对 <code>Request</code> 和 <code>Response</code>（以及其他与网络请求有关的）对象的通用定义。它同时还为有关联性的概念，例如 CORS 和 HTTP 原生头信息，提供一种新的定义，取代它们原来那种分离的定义。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>fetch</code>接收两个参数：</p><ul><li><p><code>url:</code>字符串，表示网络资源的实际地址</p></li><li><p><code>initOption:</code>可选参数，类型为对象，其中的可选字段为：</p><ul><li><code>method</code>: 请求使用的方法，如 <code>GET</code>、<code>POST</code>。</li></ul><ul><li><code>headers</code>: 请求的头信息，形式为 <code>Headers</code> 的对象或包含 <a href="https://developer.mozilla.org/zh-CN/docs/conflicting/Web/JavaScript/Reference/Global_Objects/String"><code>ByteString</code></a> 值的对象字面量。</li><li><code>body</code>: 请求的 body 信息：可能是一个 <code>Blob</code>、<code>BufferSource</code> 、<code>FormData</code>、<code>URLSearchParams</code> 或者 <code>USVString</code>对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。</li><li><code>mode</code>: 请求的模式，如 <code>cors</code>、<code>no-cors</code> 或者 <code>same-origin</code>。</li><li><code>credentials</code>: 请求的 credentials，如 <code>omit</code>、<code>same-origin</code> 或者 <code>include</code>。为了在当前域名内自动发送 cookie，必须提供这个选项，从 Chrome 50 开始，这个属性也可以接受 <code>FederatedCredential</code> 实例或是一个 <code>PasswordCredential</code> 实例。</li><li><code>cache</code>:  请求的 cache 模式：<code>default</code>、 <code>no-store</code>、 <code>reload</code> 、 <code>no-cache</code>、 <code>force-cache</code> 或者 <code>only-if-cached</code>。</li><li><code>redirect</code>: 可用的 redirect 模式：<code>follow</code> (自动重定向), <code>error</code> (如果产生重定向将自动终止并且抛出一个错误），或者 <code>manual</code> (手动处理重定向)。在 Chrome 中默认使用 <code>follow</code>（Chrome 47 之前的默认值是 <code>manual</code>）。</li><li><code>referrer</code>: 一个 <code>USVString</code>可以是 <code>no-referrer</code>、<code>client</code> 或一个 URL。默认是 <code>client</code>。</li><li><code>referrerPolicy</code>: 指定了 HTTP 头部 referer 字段的值。可能为以下值之一：<code>no-referrer</code>、 <code>no-referrer-when-downgrade</code>、<code>origin</code>、<code>origin-when-cross-origin</code>、 <code>unsafe-url</code>。</li><li><code>integrity</code>: 包括请求的 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity">subresource integrity</a> 值（例如： <code>sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=</code>）。</li><li><code>signal</code>: 与<code>AbortController</code>结合，用于取消请求。</li></ul></li></ul><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>无论<code>fetch</code>的结果如何，它都将返回一个<code>Promise</code>，并resolve一个<code>Response</code>对象，其中包含的信息如下：</p><ul><li><p><code>headers</code> 只读，包含此 Response 所关联的 <code>Headers</code> 对象。</p></li><li><p><code>ok</code> 只读,包含了一个布尔值，标示该 Response 成功（HTTP 状态码的范围在 200-299）。</p></li><li><p><code>redirected</code> 只读，表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个条目。</p></li><li><p><code>status</code> 只读，包含 Response 的状态码（例如 <code>200</code> 表示成功）。</p></li><li><p><code>statusText</code> 只读，包含了与该 Response 状态码一致的状态信息（例如，OK 对应 <code>200</code>）。</p></li><li><p><code>type</code> 只读，包含 Response 的类型（例如，<code>basic</code>、<code>cors</code>）。</p></li><li><p><code>url</code> 只读，包含 Response 的 URL。</p></li><li><p><code>useFinalURL</code> 包含了一个布尔值，来标示这是否是该 Response 的最终 URL。</p></li><li><p><code>body</code> 只读，一个简单的 getter，用于暴露一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream"><code>ReadableStream</code></a> 类型的 body 内容。</p></li><li><p><code>bodyUsed</code> 只读，包含了一个布尔值来标示该 Response 是否读取过 <code>Body</code>。</p></li></ul><p><strong>注意：</strong> 如果是请求已经发出，但是未找到目标服务器ip，或目标服务器未实现接口，导致<code>fetch</code>未接收到response，那么它会reject一个错误。</p><h2 id="封装实践"><a href="#封装实践" class="headerlink" title="封装实践"></a>封装实践</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; method </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; url </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">RequestInit</span>&#125; options </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Promise</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">method = <span class="hljs-string">&quot;get&quot;</span>, url, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">let</span> res, err;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>    <span class="hljs-attr">method</span>: method,<br>    ...options,<br>  &#125;)<br>    .<span class="hljs-title function_">then</span>(<br>      <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">responseHanlder</span>(<span class="hljs-params">response</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>        <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>          <span class="hljs-comment">// 接收到了响应，但是不是成功的响应（HTTP 状态码的范围不在 200-299）</span><br>          <span class="hljs-keyword">const</span> text = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">text</span>();<br>          <span class="hljs-keyword">const</span> error = &#123;<br>            <span class="hljs-attr">code</span>: response.<span class="hljs-property">status</span>,<br>            <span class="hljs-attr">statusText</span>: response.<span class="hljs-property">statusText</span>,<br>          &#125;;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 假设服务器响应数据格式为 &#123; code, message, data &#125;</span><br>            <span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(text);<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(&#123;<br>              ...error,<br>              <span class="hljs-attr">message</span>: json.<span class="hljs-property">message</span>,<br>            &#125;);<br>          &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(&#123;<br>              ...error,<br>              <span class="hljs-attr">text</span>: text,<br>            &#125;);<br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>      &#125;,<br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">requestErrorHandler</span>(<span class="hljs-params">err</span>) &#123;<br>        <span class="hljs-comment">// 请求已被发出，但是未接收到任何响应</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(&#123;<br>          <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>          <span class="hljs-attr">message</span>: err.<span class="hljs-property">message</span>,<br>        &#125;);<br>      &#125;<br>    )<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">_res</span>) =&gt;</span> &#123;<br>      res = _res;<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">_err</span>) =&gt;</span> &#123;<br>      err = _err;<br>    &#125;);<br>  <span class="hljs-keyword">if</span> (res) &#123;<br>    <span class="hljs-comment">// TODO 处理成功</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-comment">// TODO 处理失败</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;error&quot;</span>, err);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch">fetch - Web API 接口参考 | MDN</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request">Request - Web API 接口参考 | MDN</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response">Response - Web API 接口参考 | MDN</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Headers">Headers - Web API 接口参考 | MDN</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>JavaScript</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在Vue或React中优雅的使用SVG</title>
    <link href="/2022/02/23/%E5%A6%82%E4%BD%95%E5%9C%A8Vue%E6%88%96React%E4%B8%AD%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8SVG/"/>
    <url>/2022/02/23/%E5%A6%82%E4%BD%95%E5%9C%A8Vue%E6%88%96React%E4%B8%AD%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8SVG/</url>
    
    <content type="html"><![CDATA[<h1 id="如何在Vue或React中优雅的使用SVG"><a href="#如何在Vue或React中优雅的使用SVG" class="headerlink" title="如何在Vue或React中优雅的使用SVG"></a>如何在Vue或React中优雅的使用SVG</h1><p>最近做的项目中使用了很多的<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG">SVG</a>，按照我以往的做法，我会直接将SVG代码拷贝到所需要的HTML(React JSX或Vue Template)文件中，但是最近这个项目使用的太多了，挨个拷贝不仅很麻烦，而且还会导致代码量十分巨大，这部分代码显然是没必要的。于是我尝试寻找减少代码量的方法，并将其记录在此。</p><p><strong>注：</strong>本文以React示例，Vue同理。</p><p>首先安装<code>svg-sprite-loader</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">yarn add svg-sprite-loader --dev<br></code></pre></td></tr></table></figure><p>这个loader帮我们将svg图片打包合并在一起，并全部添加到<code>&lt;head /&gt;</code>中，我们可以在后文以<code>&lt;use href=&quot;xxx&quot; /&gt;</code>的形式使用其中的图片。</p><p>然后修改Webpack配置文件，添加一条rule：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">rules</span>: [<br>    &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.svg/</span>,<br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&quot;svg-sprite-loader&quot;</span>]<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>然后定义一个组件<code>SvgIcon</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SvgIcon</span> (props) &#123;<br>  <span class="hljs-keyword">const</span> &#123; icon &#125; = props;<br>  <span class="hljs-keyword">const</span> iconName = <span class="hljs-string">`#<span class="hljs-subst">$&#123;icon&#125;</span>`</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#123;iconName&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>注意<code>SvgIcon</code>中的代码，这个组件接受一个参数，及所需要使用的图片的<strong>id</strong>（注意id前面有个<code>#</code>），这个id默认情况下是该svg图片的文件名称，但是我们可以修改它。添加<code>svg-sprite-loader</code>的options字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">rules</span>: [<br>    &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.svg/</span>,<br>        <span class="hljs-attr">use</span>: [&#123;<br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;svg-sprite-loader&quot;</span>,<br>            <span class="hljs-attr">options</span>: &#123;<br>                <span class="hljs-comment">// 可以是一个字符串，或一个返回字符串的函数</span><br>                <span class="hljs-attr">symbolId</span>: <span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span> &#123;<br>                  <span class="hljs-keyword">return</span> path.<span class="hljs-title function_">basename</span>(filename).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\.svg$/</span>, <span class="hljs-string">&quot;&quot;</span>);<br>                &#125;<br>                <span class="hljs-comment">// or just use </span><br>                <span class="hljs-comment">// symbolId: &quot;[name]&quot;,</span><br>            &#125;<br>        &#125;]<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>接下来我们就可以在组件中用以下方式使用svg图片，例如我有一个svg图片<code>icon.svg</code>，我们只需在入口文件引入该图片，即可在任何地方使用该图片：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// main.jsx</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./svgs/icon.svg&quot;</span>;<br><br><span class="hljs-comment">// App.jsx</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">SvgIcon</span> <span class="hljs-attr">icon</span>=<span class="hljs-string">&quot;icon&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引入优化"><a href="#引入优化" class="headerlink" title="引入优化"></a>引入优化</h2><p>svg文件太多的情况下，挨个引入也是一件麻烦事，这里我们可以使用<code>require.context</code>自动引入所有的svg图片。关于<code>require.context</code>的说明，请看<a href="https://webpack.js.org/guides/dependency-management/#requirecontext">这里</a>。</p><p>比如我们有如下文件结构：</p><blockquote><p>|—svg<br>       |—a.svg<br>       |—b.svg<br>       |—c.svg</p></blockquote><p>只需要在svg文件夹内新增一个js文件，这里我命名为<code>index.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">importAll</span> (r) &#123;<br>    r.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">forEach</span>(r);<br>&#125;<br><br><span class="hljs-keyword">const</span> context = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">context</span>(<span class="hljs-string">&quot;./&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.svg$/</span>);<br><span class="hljs-title function_">importAll</span>(context);<br></code></pre></td></tr></table></figure><p>并在入口文件引入该js文件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.jsx</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;svg/index.js&quot;</span>;<br></code></pre></td></tr></table></figure><p>这个方式webpack或自动帮我们引入svg文件夹下以<code>.svg</code>结尾的文件，从而减少我们的代码量。</p><p>最后附上<a href="https://github.com/Xiaoooyooo/demos/tree/master/svg-sprite">本文源码</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/JetBrains/svg-sprite-loader">svg-sprite-loader</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG">SVG</a></li><li><a href="https://webpack.js.org/guides/dependency-management/#requirecontext">require.context</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Vue</tag>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redux：在函数组件中的使用</title>
    <link href="/2021/11/15/Redux%E5%9C%A8%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/11/15/Redux%E5%9C%A8%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Redux：在函数组件中的使用"><a href="#Redux：在函数组件中的使用" class="headerlink" title="Redux：在函数组件中的使用"></a>Redux：在函数组件中的使用</h1><p>本文基于官方推荐的工具<code>@reduxjs/toolkit</code>和<code>react-redux</code>，以及<code>typescript</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">yarn add @redux/toolkit react-redux<br></code></pre></td></tr></table></figure><h2 id="初始化store"><a href="#初始化store" class="headerlink" title="初始化store"></a>初始化store</h2><h3 id="创建store模块"><a href="#创建store模块" class="headerlink" title="创建store模块"></a>创建store模块</h3><p><code>counterStore.ts</code>：创建一个存储计数器数据的store</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; createSlice, <span class="hljs-title class_">PayloadAction</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span>;<br><span class="hljs-comment">// PayloadAction: 官方准备好的带有payload的action类型声明</span><br><span class="hljs-keyword">const</span> counterStore = <span class="hljs-title function_">createSlice</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;counter&quot;</span>,<br>    <span class="hljs-attr">initialState</span>: &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>    &#125;,<br>    <span class="hljs-attr">reducers</span>: &#123;<br>        <span class="hljs-attr">changeCount</span>: <span class="hljs-function">(<span class="hljs-params">state, action: PayloadAction&lt;<span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>&gt;</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 在createSlice中可以直接修改state对象</span><br>            state.<span class="hljs-property">count</span> += action.<span class="hljs-property">payload</span> || <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// createSlice会根据其中的reducers自动生成对应的action和reducer，我们只管使用</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; changeCount &#125; = counterStore.<span class="hljs-property">actions</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> counterStore.<span class="hljs-property">reducer</span>;<br></code></pre></td></tr></table></figure><h3 id="初始化根store"><a href="#初始化根store" class="headerlink" title="初始化根store"></a>初始化根store</h3><p><code>store.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; configureStore, combineReducers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span>;<br><br><span class="hljs-comment">// 引入刚才创建的计数器reducer</span><br><span class="hljs-keyword">import</span> counterReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./counterStore&quot;</span>;<br><br><span class="hljs-comment">// 将引入的各种reducer组合起来（虽然这里只有一个）</span><br><span class="hljs-keyword">const</span> reducer = <span class="hljs-title function_">combineReducer</span>(&#123;<br>    <span class="hljs-attr">counter</span>: counterReducer,<br>    <span class="hljs-comment">// ...其他的reducer</span><br>&#125;);<br><br><span class="hljs-comment">// 创建rootStore</span><br><span class="hljs-keyword">const</span> rootStore = <span class="hljs-title function_">configureStore</span>(&#123;<br>    <span class="hljs-attr">reducer</span>: reducer,<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> rootStore;<br><span class="hljs-comment">// 至此仅在js方面已经实现了功能，但是我们使用的是ts，所以还有额外的操作</span><br><span class="hljs-comment">// 导出数据类型</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">RootStore</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> rootStore.<span class="hljs-property">getState</span>&gt;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">AppDispatch</span> = <span class="hljs-keyword">typeof</span> rootStore.<span class="hljs-property">dispatch</span>;<br></code></pre></td></tr></table></figure><h3 id="类型推断（仅typescript）"><a href="#类型推断（仅typescript）" class="headerlink" title="类型推断（仅typescript）"></a>类型推断（仅typescript）</h3><p><code>hooks.ts</code>：封装<code>react-redux</code>中的部分钩子，如果不使用ts则不需要进行下面的操作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;<br>    useDispatch,<br>    useStore,<br>    useSelector,<br>    typedUseSelectorHook<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">RootStore</span>, <span class="hljs-title class_">AppDispatch</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store&quot;</span>;<br><br><span class="hljs-comment">// 此后在项目中使用这些hook而不是直接使用react-redux中的hook</span><br><span class="hljs-comment">// 这些hook能自动推断相应的数据类型</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useAppStore</span> = (<span class="hljs-params"></span>) =&gt; useStore&lt;<span class="hljs-title class_">RootStore</span>&gt;();<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useAppDispatch</span> = (<span class="hljs-params"></span>) =&gt; useDispatch&lt;<span class="hljs-title class_">AppDispatch</span>&gt;();<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">useAppSelector</span>: typedUseSelectorHook&lt;<span class="hljs-title class_">RootStore</span>&gt; = useSelector;<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>main.tsx</code>：项目入口文件</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDom</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./app&quot;</span>;<br><br><span class="hljs-title class_">ReactDom</span>.<span class="hljs-title function_">render</span>(<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>,<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;app&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p><code>App.tsx</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useAppStore, useAppDispatch, useAppSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./hooks&quot;</span>;<br><br><span class="hljs-comment">// 导入counter的actionCreator</span><br><span class="hljs-keyword">import</span> &#123; changeCount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./counterStore&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useAppStore</span>();<br>    <span class="hljs-keyword">const</span> countStore = <span class="hljs-title function_">useAppSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">counterStore</span>);<br>    <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useAppDispatch</span>();<br>    <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count: &#123;countStore.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(changeCount(1))&#125;&gt;increment by 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(changeCount(-1))&#125;&gt;decrement by 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://redux-toolkit.js.org/tutorials/typescript">redux-toolkit usage with ts</a></li><li><a href="https://react-redux.js.org/using-react-redux/usage-with-typescript">react-redux usage with ts</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redux</tag>
      
      <tag>@reduxjs/toolkit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Grid 布局</title>
    <link href="/2021/05/30/Grid%20%E5%B8%83%E5%B1%80/"/>
    <url>/2021/05/30/Grid%20%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Grid-布局"><a href="#Grid-布局" class="headerlink" title="Grid 布局"></a>Grid 布局</h1><p>即网格布局，它将元素按行列分为多个不同的“块”，使子项目位于这些块中，从而能实现更为复杂的布局。它类似于flex布局，但是比flex布局更为强大。</p><p>使用grid布局的元素称为容器，其内部的直接子元素则为项目。</p><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="grid-template-columns-grid-template-rows"><a href="#grid-template-columns-grid-template-rows" class="headerlink" title="grid-template-columns, grid-template-rows"></a>grid-template-columns, grid-template-rows</h3><p>前者用于定义容器的列，后者定义容器的行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.el</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 定义3列，每列宽100px */</span><br>    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 定义3行，每行高100px */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果定义的每行每列宽高都一致的话，则可以使用<code>repeat</code>函数简写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.el</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">100px</span>); <span class="hljs-comment">/* 定义3列，每列宽100px */</span><br>    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">100px</span>); <span class="hljs-comment">/* 定义3行，每行高100px */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要使列数尽可能的适应容器宽度，则可以使用<code>auto-fill</code>关键字使列数在不超过容器宽度的情况下尽可能的多：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.el</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">100px</span>); <span class="hljs-comment">/* 列数尽可能多，每列宽100px */</span><br>    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">100px</span>); <span class="hljs-comment">/* 定义3行，每行高100px */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fr-关键字"><a href="#fr-关键字" class="headerlink" title="fr 关键字"></a>fr 关键字</h3><p>仅在grid布局中生效的关键字，用于表示相对宽度。（类似于flex布局中<code>flex-grow</code>与<code>flex-shrink</code>）</p><h3 id="minmax-函数"><a href="#minmax-函数" class="headerlink" title="minmax() 函数"></a>minmax() 函数</h3><p>该函数产生一个长度范围，接受最小和最大两个参数。</p><p>如果最大值大于最小值，则<code>minmax(最大值, 最小值)</code>被看作是<code>最小值</code>；反之取最大值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.el</span> &#123;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">1</span>fr);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="auto-关键字"><a href="#auto-关键字" class="headerlink" title="auto 关键字"></a>auto 关键字</h3><p>auto关键字表示该行&#x2F;列所占的宽&#x2F;高度由该行&#x2F;列中最大的项目决定，确保该行&#x2F;列能完整容下所有项目。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.el</span> &#123;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> auto <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述css代码表示第二列宽度自适应，一般为容器最大剩余空间，除非使用<code>max-width</code>做了限制</p><h3 id="网格线的名称"><a href="#网格线的名称" class="headerlink" title="网格线的名称"></a>网格线的名称</h3><p>网格线可用于子项目的定位。</p><p>在定义网格的同时，可以使用<code>[]</code>在每行、列网格之间定义网格线的名称，方便之后的引用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.el</span> &#123;<br>    <span class="hljs-attribute">grid-template-columns</span>: [c1] <span class="hljs-number">100px</span> [c2] <span class="hljs-number">100px</span> [c3];<br>    <span class="hljs-attribute">grid-template-rows</span>: [r1] <span class="hljs-number">100px</span> [r2] <span class="hljs-number">100px</span> [r3];<br>&#125;<br></code></pre></td></tr></table></figure><p>一根网格线允许拥有多个名称，只需在<code>[]</code>中使用空格隔开。</p><h3 id="网格间距"><a href="#网格间距" class="headerlink" title="网格间距"></a>网格间距</h3><p>可以使用<code>grid-column-gap</code>和<code>grid-row-gap</code>定义网格之间的最小间距：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.el</span> &#123;<br>    <span class="hljs-attribute">grid-row</span>-<span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">grid-column</span>-<span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br><br>    <span class="hljs-comment">/* 简写 */</span><br>    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;<br>    <span class="hljs-comment">/* 或 */</span><br>    <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网格区域"><a href="#网格区域" class="headerlink" title="网格区域"></a>网格区域</h3><p>使用<code>grid-template-areas</code>定义网格区域：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.el</span> &#123;<br>    <span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&quot;a b c&quot;</span> <span class="hljs-string">&quot;d e f&quot;</span> <span class="hljs-string">&quot;g h i&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码定义了一个3*3的网格，共九个区域。还可以使某些区域的名称相同，从而合并这些区域：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.el</span> &#123;<br>    <span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&quot;header header header&quot;</span> <span class="hljs-string">&quot;main main sider&quot;</span> <span class="hljs-string">&quot;footer footer footer&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：如有不需要使用的区域，则可以用<code>.</code>填充相应的区域。区域的命名会影响到网格线，每个区域的起始网格线和结束网格线分别为：<code>&lt;区域名&gt;-start</code>和<code>&lt;区域名&gt;-end</code></p><h3 id="网格排列顺序"><a href="#网格排列顺序" class="headerlink" title="网格排列顺序"></a>网格排列顺序</h3><p>使用<code>grid-auto-flow</code>定义网格排列顺序：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.el</span> &#123;<br>    <span class="hljs-attribute">grid-auto-flow</span>: [row | column] || dense;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>dense</code>为可选值，作用为某些元素指定了排布位置或大小而其附近留下了较大的空白，则后续出现的较小的元素将会尝试填充这些空白。</p><h3 id="自定义超出网格项目的大小"><a href="#自定义超出网格项目的大小" class="headerlink" title="自定义超出网格项目的大小"></a>自定义超出网格项目的大小</h3><p>容器的大小计算方法为：<code>列数 * 行数</code>，如果子项目的数量超出了这个数，那么一部分子项目将会超出容器。</p><p>如果子项目超出了容器内部，则浏览器会自动生成合适数量的行或列来适应该项目的位置，默认情况下生成的行列宽高为其内容的大小。</p><p>可以使用<code>grid-auto-columns</code>和<code>grid-auto-rows</code>指定生成的单元格的大小：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.el</span> &#123;<br>    <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">grid-auto-columns</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="根据网格线定位"><a href="#根据网格线定位" class="headerlink" title="根据网格线定位"></a>根据网格线定位</h3><ul><li><code>grid-column-start</code>：设置当前项目的起始列网格线编号；</li><li><code>grid-column-end</code>：设置当前项目的结束列网格线编号，不设置默认为起始列网格线加1。<ul><li>上面两个可缩写为：<code>grid-column: start / end</code>，当只跨过一列时，<code>end</code>可不写。</li></ul></li><li><code>grid-row-start</code>：设置当前项目的结束行网格线编号；</li><li><code>grid-row-end</code>：设置当前项目的结束行网格线编号，不设置默认为起始行网格线加1。<ul><li>上面两个可以缩写为：<code>grid-row: start / end</code>，当只跨过一行时，<code>end</code>可不写。</li></ul></li></ul><p>上面四个属性可简写为：<code>grid-area: row-start / column-start/ row-end / column-end</code>。</p><p>其余未设置定位的项目按剩余空间按顺序分配位置。</p><h4 id="span关键字"><a href="#span关键字" class="headerlink" title="span关键字"></a>span关键字</h4><p>用于定义当前项目跨越的行&#x2F;列数，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.el</span> &#123;<br>    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>; <span class="hljs-comment">/* 以第一条列网格线为起点，跨过2列 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="网格布局与flex布局的区别"><a href="#网格布局与flex布局的区别" class="headerlink" title="网格布局与flex布局的区别"></a>网格布局与flex布局的区别</h2><p>网格布局：二维布局，能控制项目在行和列上的行为；</p><p>flex布局：一维布局，仅能控制项目在行或列单一方向上的布局。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout">网格布局的基本概念</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Relationship_of_Grid_Layout">grid layout 和其它布局方法的联系</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中的Render函数</title>
    <link href="/2021/04/07/Vue%E4%B8%AD%E7%9A%84Render%E5%87%BD%E6%95%B0/"/>
    <url>/2021/04/07/Vue%E4%B8%AD%E7%9A%84Render%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue中的Render函数"><a href="#Vue中的Render函数" class="headerlink" title="Vue中的Render函数"></a>Vue中的Render函数</h1><p>Vue建议我们尽量使用<code>template</code>模板创建我们的HTML结构，但在一些场景则显得不是很灵活，这时候我们就可以使用JS的完全编程能力，而Vue就为此实现了<code>render</code>选项。</p><p><code>render</code>为Vue实例选项中的属性之一，它是一个函数，返回一个<code>VNode</code>，接受一个形参<code>cereateElement</code>，这个形参也是一个函数。</p><p>在基于Webpack的Vue项目的入口文件中，我们就经常使用到这个render函数：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">createElement</span> =&gt;</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">App</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>它的作用是将返回的<code>VNode</code>作为HTML编译模板，并渲染到页面中，并且<code>render</code>函数的优先级比<code>template</code>和<code>el</code>中的模板更高。</p><h2 id="createElement函数"><a href="#createElement函数" class="headerlink" title="createElement函数"></a>createElement函数</h2><p>在<code>render</code>函数中Vue会默认传递一个参数<code>createElement</code>，用于创建一个<code>VNode</code>，即“虚拟节点（virtual node）”，顾名思义，这不是一个真的DOM元素，而是一个DOM节点的描述信息。</p><h3 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h3><p><code>createElement</code>能接受三个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">createElement</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String | Object | Function</span>&#125;</span><br><span class="hljs-comment">     *   一个 HTML 标签名、组件选项对象，或者 resolve 了上述任何一种的一个 async 函数。必填项。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@parma</span> &#123;<span class="hljs-type">Object</span>&#125;</span><br><span class="hljs-comment">     *   一个与模板中 attribute 对应的数据对象。可选。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String | Array</span>&#125;</span><br><span class="hljs-comment">     *   子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，也可以使用字符串来生成“文本虚拟节点”。可选。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">VNode</span>&#125;</span><br><span class="hljs-comment">     */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于它的第二个参数对象的内容具体如下：</p><ul><li><code>class</code>：与 <code>v-bind:class</code> 的 API 相同，接受一个字符串、对象或字符串和对象组成的数组</li><li><code>style</code>：与 <code>v-bind:style</code> 的 API 相同，接受一个字符串、对象，或对象组成的数组</li><li><code>attrs</code>：普通的 HTML attribute</li><li><code>props</code>：传递给组件的 prop</li><li><code>domProps</code>：DOM属性，如<code>innerHTML, value</code></li><li><code>on</code>：定义事件监听器，但不再支持如 <code>v-on:keyup.enter</code> 这样的修饰器。需要在处理函数中手动检查 keyCode。</li><li><code>nativeOn</code>：仅用于组件监听原生事件，而不是在组件内使用<code>vm.$emit</code> 触发的事件。</li><li><code>directives</code>：使用自定义指令，无法对 <code>binding</code> 中的 <code>oldValue</code> 赋值，因为 Vue 已经自动为你进行了同步。</li><li><code>scopedSlots</code>：传入插槽</li><li><code>slot</code>：如果组件是其它组件的子组件，需为插槽指定名称</li><li><code>key</code>：列表渲染</li><li><code>ref</code>：引用</li><li><code>refInfo</code>：如果你在渲染函数中给多个元素都应用了相同的 ref 名，那么 <code>$refs.myRef</code> 会变成一个数组。</li></ul><h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 渲染HTML</span><br><span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;h1&quot;</span>, &#123;<br>    <span class="hljs-attr">class</span>: [<span class="hljs-string">&quot;test&quot;</span>, &#123;<span class="hljs-attr">test1</span>:<span class="hljs-literal">true</span>&#125;],<br>    <span class="hljs-attr">style</span>: <span class="hljs-string">&quot;color: red&quot;</span>,<br>    <span class="hljs-attr">attrs</span>: &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;test&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">on</span>: &#123;<br>        <span class="hljs-attr">click</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Clicked!&quot;</span>)<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">ref</span>: <span class="hljs-string">&quot;test&quot;</span><br>&#125;, <span class="hljs-string">&quot;这是一个标题&quot;</span>)<br><br><span class="hljs-comment">//渲染组件 例如一个输入框组件 myInut</span><br><span class="hljs-title function_">createElement</span>(myInput, &#123;<br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;foo&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">nativeOn</span>: &#123;<br>        <span class="hljs-attr">click</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Component Clicked!&quot;</span>)<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">directives</span>: [&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;red&quot;</span><br>    &#125;],<br>    <span class="hljs-attr">scopedSlots</span>: &#123;<br>        <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;span&quot;</span>, props.<span class="hljs-property">text</span>)<br>    &#125;,<br>    <span class="hljs-attr">slot</span>: <span class="hljs-string">&quot;myInput&quot;</span>,<br>    <span class="hljs-attr">ref</span>: <span class="hljs-string">&quot;myInput&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p><strong>VNode必须唯一</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//不合法的写法</span><br><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>  <span class="hljs-keyword">var</span> myParagraphVNode = <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;hi&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, [<br>    <span class="hljs-comment">// 错误 - 重复的 VNode</span><br>    myParagraphVNode, myParagraphVNode<br>  ])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>在某些情况下，使用<code>render</code>函数会使我们的代码十分不美观，例如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">createElement</span>(<br>  <span class="hljs-string">&#x27;anchored-heading&#x27;</span>, &#123;<br>    <span class="hljs-attr">props</span>: &#123;<br>      <span class="hljs-attr">level</span>: <span class="hljs-number">1</span><br>    &#125;<br>  &#125;, [<br>    <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>),<br>    <span class="hljs-string">&#x27; world!&#x27;</span><br>  ]<br>)<br></code></pre></td></tr></table></figure><p>而与此对应的jsx模板为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;anchored-heading :level=<span class="hljs-string">&quot;1&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span> world!<br>&lt;/anchored-heading&gt;<br></code></pre></td></tr></table></figure><p>孰好孰坏一目了然。Babel中就有一个插件，可以让我们在Vue中使用JSX语法，使用此语法上面的模板完整写法可为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">AnchoredHeading</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./AnchoredHeading.vue&#x27;</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#demo&#x27;</span>,<br>  <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">h</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AnchoredHeading</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&#123;1&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> world!</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">AnchoredHeading</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>将 <code>h</code> 作为 <code>createElement</code> 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的。从 Vue 的 Babel 插件的 <a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection">3.4.0 版本</a>开始，我们会在以 ES2015 语法声明的含有 JSX 的任何方法和 getter 中 (不是函数或箭头函数中) 自动注入 <code>const h = this.$createElement</code>，这样你就可以去掉 <code>(h)</code> 参数了。对于更早版本的插件，如果 <code>h</code> 在当前作用域中不可用，应用会抛错。</p></blockquote><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install @vue/babel-preset-jsx @vue/babel-helper-vue-jsx-merge-props<br></code></pre></td></tr></table></figure><p>然后再babel配置文件中添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@vue/babel-preset-jsx&#x27;</span>],<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong>jsx模板需要写在新的<code>.jsx</code>文件中，而不能仅仅将<code>.vue</code>文件中的<code>script</code>部分的<code>lang</code>设置为jsx。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cn.vuejs.org/v2/guide/render-function.html">渲染函数 &amp; JSX</a></li><li><a href="https://github.com/vuejs/jsx#installation">Vue&#x2F;Babel Preset JSX</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端框架</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React State</title>
    <link href="/2021/03/21/React%20State/"/>
    <url>/2021/03/21/React%20State/</url>
    
    <content type="html"><![CDATA[<h1 id="React-State"><a href="#React-State" class="headerlink" title="React State"></a>React State</h1><p>state定义在组件的构造函数中，用于保存当前组件的一些状态，其中保存的数据都能参与到数据流当中。我们也可以随意在组件的this中添加不参与数据流的额外字段（如<code>this.timer</code>）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(props)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            <span class="hljs-comment">// 此处定义参与数据流的字段</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">myFn</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// 定义仅在当前组件有效且不参与数据流的字段</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hello</span> = <span class="hljs-string">&#x27;hello&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="正确地使用State"><a href="#正确地使用State" class="headerlink" title="正确地使用State"></a>正确地使用State</h2><h3 id="1-不要直接修改state"><a href="#1-不要直接修改state" class="headerlink" title="1.不要直接修改state"></a>1.不要直接修改state</h3><p>直接修改state不会将被修改地数据实时反映到页面上，如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Wrong</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">comment</span> = <span class="hljs-string">&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>而是应该使用<code>setState</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Correct</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>    <span class="hljs-attr">comment</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2-State的更新可能是异步的"><a href="#2-State的更新可能是异步的" class="headerlink" title="2.State的更新可能是异步的"></a>2.State的更新可能是异步的</h3><p>出于性能考虑，React可能会将多个<code>setState</code>调用合并为一个调用。</p><p>由于 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以我们不能依赖它们的值来更新下一个状态。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Wrong 此代码可能会无法更新计数器</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">increment</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>要解决这个问题，我们可以让<code>setState</code>接收一个函数而不是一个对象作为参数，并返回需要修改的属性集合对象，这个函数用上一个state作为第一个参数，此次更新被应用的props作为第二个参数。同时这个函数用箭头函数或普通函数都行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">steState</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">state, props</span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + props.<span class="hljs-property">increment</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="3-State的更新会被合并"><a href="#3-State的更新会被合并" class="headerlink" title="3.State的更新会被合并"></a>3.State的更新会被合并</h3><p>当我们调用<code>setState</code>时，React会将我们提供的对象合并到当前的State。</p><p>意思是说如果我们在State中定义了几个变量，而我们现在需要修改其中的一个，React会将我们提供的修改对象合并到原来的State中，而不会修改其他无需修改的数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fetchPosts</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>          <span class="hljs-comment">//只会修改State中的posts属性</span><br>        <span class="hljs-attr">posts</span>: response.<span class="hljs-property">posts</span><br>      &#125;);<br>    &#125;);<br><br>    <span class="hljs-title function_">fetchComments</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>          <span class="hljs-comment">//只会修改State中的comments属性</span><br>        <span class="hljs-attr">comments</span>: response.<span class="hljs-property">comments</span><br>      &#125;);<br>    &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里的合并指的是浅合并，所以 <code>this.setState(&#123;comments&#125;)</code> 完整保留了<code>this.state.posts</code>， 但是完全替换了 <code>this.state.comments</code>。</p><h2 id="数据是向下流动的"><a href="#数据是向下流动的" class="headerlink" title="数据是向下流动的"></a>数据是向下流动的</h2><p>在React中，不管是父组件还是子组件，它们都无法得知对方是否是有状态的，而且它们也无法得知对方是函数组件还是class组件。这就是称state为局部的或是封装的的原因。除了拥有并设置它的组件，其余组件都无法访问。</p><p>组件可以选择将它的state作为props向下传递到它的子组件中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">FormattedDate</span> date=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">date</span>&#125; /&gt;<br></code></pre></td></tr></table></figure><p><code>FormattedDate</code> 组件会在其 props 中接收参数 <code>date</code>，但是它本身无法知道<code>date</code>属性是来自于 <code>Clock</code> 的 state，或是 <code>Clock</code> 的 props，还是手动输入的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FormattedDate</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p><p>在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html">React State</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端框架</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始搭建一个React APP</title>
    <link href="/2021/03/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAReact%E5%BA%94%E7%94%A8/"/>
    <url>/2021/03/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAReact%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="从零开始搭建一个React-APP"><a href="#从零开始搭建一个React-APP" class="headerlink" title="从零开始搭建一个React APP"></a>从零开始搭建一个React APP</h1><p>Facebook早已为开发者提供了一个搭建React APP的工具，即<a href="https://github.com/facebook/create-react-app">create-react-app</a>，但怀着学习的态度，我还是想要了解一下如何使用Node从零搭建一个React APP的开发环境，因此我写下了这篇日志。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>创建应用文件夹</p></li><li><p>使用<code>npm init</code>初始化当前文件夹，使用<code>git init</code>初始化git仓库</p></li><li><p>创建目录结构如下：</p><blockquote><p>.</p><p>+– public<br>+– src</p></blockquote></li><li><p>考虑到在提交至git仓库时我们并不希望打包后的文件和node模块中的文件被一同提交，我们在当前目录新建一个<code>.gitignore</code>文件用于排除特定的文件，其内容如下：</p><blockquote><p>&#x2F;node_modules</p><p>&#x2F;dist</p></blockquote></li><li><p><code>public</code>文件夹用于保存一些静态资源文件，最重要的是保存用于呈现我们的React APP的index.html文件，index.html文件的内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- sourced from https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>React Starter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 呈现React应用 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><br>    You need to enable JavaScript to run this app.<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 导入打包后的文件 --&gt;</span>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../dist/bundle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>使用<code>npm install --save-dev @babel/core@7.1.0 @babel/cli@7.1.0 @babel/preset-env@7.1.0 @babel/preset-react@7.0.0</code>安装Babel及其一些功能包（@后面是版本号，用于手动指定安装版本）。其中<code>babel-core</code>是babel的主要功能包，<code>babel-cli</code>允许我们在命令行编译文件，<code>preset-env</code>及<code>preset-react</code>帮我们预设了一些代码转换风格，不同的是后者是将JSX语法转为传统的JS语法。</p><p>在工程文件根目录创建<code>.babelrc</code>，告诉babel我们将要使用<code>env</code>与<code>react</code>转换风格</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/env&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;@babel/preset-react&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>安装webpack所需要的一些包<code>npm install --save-dev webpack@4.19.1 webpack-cli@3.1.1 webpack-dev-server@3.1.8 style-loader@0.23.0 css-loader@1.0.0 babel-loader@8.0.2</code>。webpack使用不同的loader来处理不同类型的文件以进行打包。新建<code>webpack.config.js</code>文件，其内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./src/index.js&quot;</span>,<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;development&quot;</span>,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(js|jsx)$/</span>,<br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/(node_modules|bower_components)/</span>,<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span>,<br>        <span class="hljs-attr">options</span>: &#123; <span class="hljs-attr">presets</span>: [<span class="hljs-string">&quot;@babel/env&quot;</span>] &#125;<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>]<br>      &#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">resolve</span>: &#123; <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.jsx&quot;</span>] &#125;,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;dist/&quot;</span>),<br>    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&quot;/dist/&quot;</span>,<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;public/&quot;</span>),<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,<br>    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&quot;http://localhost:3000/dist/&quot;</span>,<br>    <span class="hljs-attr">hotOnly</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>()]<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>首先安装React的两个依赖：<code>react</code>和<code>react-dom</code>，然后在index.js文件中引入react，并告诉react我们需要呈现内容的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDom</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.js&#x27;</span><br><br><span class="hljs-title class_">ReactDom</span>.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">App</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>))<br></code></pre></td></tr></table></figure><p><code>ReactDom.render</code>是一个函数，用于告诉react我们用什么在何处呈现内容，例如此处意思是我们将要使用一个叫App的组件（稍后创建）渲染在<code>id=root</code>的元素中。</p><p>现在，在src文件夹中创建一个App.js文件，其内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;<span class="hljs-title class_">Component</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Components</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello React<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>注意上文中引入了css文件。</p><p>至此我们拥有了一个能够运行的React APP，此时我们的目录结构应该是这样的：</p><blockquote><p>.<br>+– public<br>| +– index.html<br>+– src<br>| +– App.css<br>| +– App.js<br>| +– index.js<br>+– .babelrc<br>+– .gitignore<br>+– package-lock.json<br>+– package.json<br>+– webpack.config.js</p></blockquote><p>使用<code>npx webpack serve</code>运行。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，一个不需要使用<code>create-react-app</code>的React APP已经搭建完成了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658">Creating a React App… From Scratch.</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端框架</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记2021-03-19</title>
    <link href="/2021/03/19/%E8%AE%B02021-03-19/"/>
    <url>/2021/03/19/%E8%AE%B02021-03-19/</url>
    
    <content type="html"><![CDATA[<h1 id="记2021-03-19"><a href="#记2021-03-19" class="headerlink" title="记2021-03-19"></a>记2021-03-19</h1><p><strong>— 2021年3月19日下午 字节跳动</strong></p><p>面试持续了四十多分钟，问的问题对于目前的我来说范围太广、太深了，没怎么问基础，好多没能答出来，导致我信心逐渐崩溃，在面试过程中完全处于被动状态，开始十多分钟我就知道已经结束了。</p><p>最后的一道编程题受心情影响完全没能集中精力，硬是厚脸皮地撑了十多分钟还是没能写出来，然后我放弃了。</p><p>很难受，虽然这个结果在意料之中，但是没想到又输得这么狼狈。</p><blockquote><p>什么是渐进式框架（不了解）</p><p>vue与jQuery有什么区别（不了解，按自己的理解答了下）</p><p>Web安全（不了解）</p><p>postman怎么实现的（不了解）</p><p>前端性能优化方案（答了一部分自己常用的）</p><p>Mongodb如何备份（不了解）</p><p>强制缓存与协商缓存（后者的回答面试官不太满意）</p><p>webpack插件写过没（没写过）</p><p>webpack loader怎么工作的（不了解）</p><p>nginx反向代理不同端口到不同路由（实践过，但回答面试官貌似不太满意）</p><p>编程题（心态已崩，脑子已离线）：</p><ul><li>实例的方法与类的方法</li><li>（过程中我写了个在题中没有提及的方法，被打断，问我为什么要写这个方法，我理解的是不能写除add以外的实例方法，遂删除代码）</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 期望执行下面代码：</span><br><span class="hljs-comment">// const cash1 = new Cash(105);</span><br><span class="hljs-comment">// const cash2 = new Cash(66);</span><br><span class="hljs-comment">// const cash3 = cash1.add(cash2);</span><br><span class="hljs-comment">// const cash4 = Cash.add(cash1, cash2);</span><br><span class="hljs-comment">// const cash5 = new Cash(cash1 + cash2);</span><br><span class="hljs-comment">// console.log(`$&#123;cash3&#125;`, `$&#123;cash4&#125;`, `$&#123;cash5&#125;`);</span><br><span class="hljs-comment">// 希望输出结果为：</span><br><span class="hljs-comment">// 1元7角1分，1元7角1分 ，1元7角1分</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cash</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">cash = <span class="hljs-number">0</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">total</span> = cash;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalStr</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>();<br>    &#125;<br>    <span class="hljs-title function_">_init</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//这里当时犯了个错，使用的是parseInt而不是Math.floor，编辑器报错我半天没找出错误原因</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalStr</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Math</span>.floor(<span class="hljs-variable language_">this</span>.total / <span class="hljs-number">100</span>)&#125;</span>元<span class="hljs-subst">$&#123;<span class="hljs-built_in">Math</span>.floor(<span class="hljs-variable language_">this</span>.total % <span class="hljs-number">100</span> / <span class="hljs-number">10</span>)&#125;</span>角<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.total % <span class="hljs-number">100</span> % <span class="hljs-number">10</span>&#125;</span>分`</span>;<br>    &#125;<br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalStr</span>;<br>    &#125;<br>    <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">total</span>;<br>    &#125;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> total = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, curr</span>) =&gt;</span> prev + curr.<span class="hljs-property">total</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">total</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cash</span>(total);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> total = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, curr</span>) =&gt;</span> curr.<span class="hljs-property">total</span> + prev, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">this</span>(total);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> cash1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cash</span>(<span class="hljs-number">105</span>);<br><span class="hljs-keyword">const</span> cash2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cash</span>(<span class="hljs-number">66</span>);<br><span class="hljs-keyword">const</span> cash3 = cash1.<span class="hljs-title function_">add</span>(cash2);<br><span class="hljs-keyword">const</span> cash4 = <span class="hljs-title class_">Cash</span>.<span class="hljs-title function_">add</span>(cash1, cash2);<br><span class="hljs-keyword">const</span> cash5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cash</span>(cash1 + cash2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;cash3&#125;</span>`</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;cash4&#125;</span>`</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;cash5&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>最后面试官问我有没有什么想要问的，当时我已经完全崩溃了，只想着赶紧结束得了，遂回答没什么想问的，面试官此时好像笑了下，紧接着问真的没有吗，我再次回答没有，至此面试结束。</p><p>这次面试使我难受了好长时间，我不知道为什么会这么难，等到冷静下来后我仔细反思了下，我真应该当场“发泄”下自己的情绪：</p><ul><li><p>这是校招还是社招</p></li><li><p>我面试的是什么岗位</p></li><li><p>为什么这么难</p></li><li><p>一个初级前端工程师应该掌握哪些前端技术</p></li></ul><p><strong>总结</strong></p><p>很难，心态还逐渐被击溃。</p><p>这已经是第二次了，可惜没能把握住。</p><p>还是太高估了自己，亦或是我低估了对面。</p><p>虽然这是意料之中的结果，但现实总是比想象更加残酷一点。</p><p>这可能是一条艰难的路，如今想回头是不可能的了，况且我也不想放弃。</p><p>总的来说还是自己挨的打太少，经不起折磨，容易受心情影响，有待改正。</p><p>如今今日已成为历史，唯有吸取教训，方能来日再挑战。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承实现的方式</title>
    <link href="/2021/03/16/%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/03/16/%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="继承实现的方式"><a href="#继承实现的方式" class="headerlink" title="继承实现的方式"></a>继承实现的方式</h1><p>在大多数的面向对象语言中都支持两种继承方式，接口继承和实现继承，但由于JS不是面向对象的编程语言，所以它并不具有面向对象编程语言的特性，它仅支持实现继承，这种实现继承也主要靠原型链来实现。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>开始之前需要弄清楚三个概念：构造函数，原型和实例。每个构造函数中都存在一个原型对象，该对象内部存在一个指针指向当前构造函数，而在每个实例中都存在一个指向原型对象的指针。如果我们将一个构造函数A的原型指向另一个构造函数B的实例，此时A的实例中的原型对象指针也就指向了B的实例，间接能够访问到B原型对象上的属性和方法。这便是原型链的概念。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Super</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sub</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Super</span>()<br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Sub</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&#x27;Hi&#x27;</span><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>()<br>instance.<span class="hljs-property">sayHello</span> <span class="hljs-comment">// hello</span><br>instance.<span class="hljs-property">greeting</span> <span class="hljs-comment">//Hi</span><br><br>instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Super</span> <span class="hljs-comment">//true</span><br>instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Sub</span> <span class="hljs-comment">//true</span><br><span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance)<span class="hljs-comment">//true</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>当父类中存在引用类型的属性时，子类的实例便会共享同一个引用类型属性</li><li>不能向父类构造函数传递参数</li></ul><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>由于原型链继承父类中存在引用类型属性时而带来的问题，开发人员开始了使用该方法，即在子类的构造函数中调用父类的构造函数，这样每个子类的实例都将获得独一无二的引用类型属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Super</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>]<br>&#125;<br><span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&#x27;Hi&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sub</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Super</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>()<br>instance.<span class="hljs-property">greeting</span><span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>子类只能访问定义在父类构造函数中的属性和方法，定义在父类原型对象上的属性和方法不能被继承</li></ul><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>也被叫做伪经典继承，是指将原型链和借用构造函数组合到一起使用而实现的继承方式，即使用原型链继承父类原型对象上的属性和方法，借用构造函数继承父类构造函数中定义的属性和方法。该方法为JS中最常用的继承实现方式，且<code>instanceof</code>和<code>isPrototypeOf</code>也能识别使用该方法创建的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Super</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>]<br>&#125;<br><span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&#x27;Hi&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sub</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-comment">// 调用父类构造函数以继承父类构造函数中定义的属性和方法</span><br>    <span class="hljs-title class_">Super</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name)<br>&#125;<br><span class="hljs-comment">// 继承定义在父类原型对象上的属性和方法</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Super</span>()<br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Sub</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-string">&#x27;Hello&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>由于在继承实现过程中调用了两次父类构造函数（第一次继承了父类的原型对象，第二次继承了父类构造函数中的属性和方法），这导致父类构造函数中的属性被声明定义了两次，浪费了不必要的内存空间</li></ul><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>用于继承对象</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>同上</p><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>该方法解决了组合继承的缺点，其思想是不必为了指定子类的原型而调用父类的构造函数，我们需要的无非就是一个父类原型的副本而已。本质上就是使用继承式继承来继承父类的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 寄生式继承思路</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">Super, Sub</span>)&#123;<br>    <span class="hljs-keyword">let</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<span class="hljs-comment">//获取父类对象的原型对象副本</span><br>    prototype.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Sub</span><span class="hljs-comment">// 指定构造函数</span><br>    <span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype<span class="hljs-comment">//指定原型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Super</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>]<br>&#125;<br><span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&quot;Hi!&quot;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sub</span>(<span class="hljs-params">name</span>)&#123;<br><span class="hljs-title class_">Super</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name)    <br>&#125;<br><span class="hljs-comment">// inherit(Super, Sub)</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Sub</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-string">&quot;Hello!&quot;</span><br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>(<span class="hljs-string">&#x27;tom&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>集寄生式继承和组合式继承的优点于一身，是实现基于类型继承的最有效方式</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《JavaScript高级程序设计》 P.162</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2021/03/10/%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/03/10/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>此篇文章用于记录本人对排序算法的学习以及记录，不定期进行补充。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序就是在一个给定的数组中，依次比较相邻的两个数，逐渐将大（或小）的数交换到数组的一侧，整个过程就像冒泡一般，故称冒泡排序。</p><p><strong>理论描述</strong></p><ul><li>从数组的第一个元素开始，比较相邻两个数的大小，如果前一个比后一个大，则交换这两个数的位置；</li><li>比较下一对相邻的数，直到数组的末尾，这一轮比较就会得出一个未排序部分中的一个最大数；</li><li>针对未排序部分进行上述操作；</li><li>重复以上步骤直到数组排序完成。</li></ul><p><strong>动图演示</strong></p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="冒泡排序"></p><p><strong>代码实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-comment">//外层循环，理论上有多少个数就需要循环多少次，但最后只剩一个数字未排序时就可以不用在继续了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-comment">//内层循环，仅在未排序的部分循环比较</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span> - i; j++)&#123;<br>            arr[i] &gt; arr[i + <span class="hljs-number">1</span>] &amp;&amp; ([[arr[i], arr[i + <span class="hljs-number">1</span>]] = [arr[i + <span class="hljs-number">1</span>], arr[i]])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序的原理就是在数组当中的未排序的序列中进行比较，选出一个最小（或最大）的数插入到有序序列中的尾部（或头部）</p><p><strong>理论描述</strong></p><ul><li>循环开始时选取当前未排序序列的第一个为最小值，记下当前最小值的索引；</li><li>将当前最小值与所遍历到的值作比较，如果当前值小于最小值，则更新最小值的索引为当前值的索引；</li><li>遍历到末尾时，将最小值插入到有序序列末尾（将最小值与无序序列的第一位做交换，有序序列在数组头部）；</li><li>对无序序列重复以上操作。</li></ul><p><strong>动图演示</strong></p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="选择排序"></p><p><strong>代码实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectionSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-comment">// minIndex用于保存最小值的索引</span><br>    <span class="hljs-keyword">let</span> minIndex<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-comment">// 外层循环，开始时将第一个值默认设为最小值</span><br>        minIndex = i<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; j++)&#123;<br>            <span class="hljs-comment">// 内层循环，从无序序列的第二个值开始比较</span><br>            arr[minIndex] &gt; arr[i] &amp;&amp; (minIndex = i)<br>        &#125;<br>        <span class="hljs-comment">// 将最小值与无序序列的第一项交换</span><br>        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>在未排序序列中选择第一个数，将它与有序序列中的每一项从后往前依次进行比较，每次比较如果该数小于所比较的数，则交换这两个数的位置，否则说明位置正确，从无序序列中选取下一个数重复这个流程。</p><p><strong>理论描述</strong></p><ul><li>默认数组的第一个数已经是正确位置；</li><li>将无序序列第一个数作为当前需要排序的数，下文简称目标数；</li><li>将目标数从后之前依次与有序序列中的数作比较，如果目标数小于所比较数，则交换两数的位置；</li><li>如果目标数大于所比较数，则说明目标数位置正确；</li><li>重复步骤2至步骤4，直至排序完成。</li></ul><p><strong>动图演示</strong></p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt="插入排序"></p><p><strong>代码实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-comment">//外层循环，默认数组的第一个数已经在正确位置</span><br>        <span class="hljs-comment">//从数组的第二个数开始排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &gt; <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-comment">//内层循环，</span><br>            <span class="hljs-comment">//如果目标数大于比较数，则说明目标数位置正确，不用再继续了</span><br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span><br>            <span class="hljs-comment">//否则交换这两个数的位置</span><br>            [arr[j], arr[j - <span class="hljs-number">1</span>]] = [arr[j - <span class="hljs-number">1</span>], arr[j]]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/onepixel/p/7674659.html">十大经典排序算法（动图演示）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找算法</title>
    <link href="/2021/03/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/03/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h1><p>如果给定一个<strong>有序的</strong>数值数组，现在需要从中查找一个指定的元素，最简单的方式便是依次遍历数组中的元素，当遍历到了所需要查找的元素时，就将这个元素返回即可。然而最简单的方式并不一定是最有效的方式，如果这个数组含有n个元素，那么通过这种查找方式所需要的查找次数最多就需要n次，这显然是没有必要的。</p><p>如同我们查英文字典一样，如果查找一个以k开头的，我们一般都是直接翻到字典的中间开始找，因为我们知道k在字母顺序中排在中间位置，从中间开始查找能够节省我们不少时间。基于这种理论，二分查找算法就出现了，它有效减少我们查找所需要花费的步骤，提升我们的查找效率。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>例如现在有一个有序数组：<code>[1,2,3,4,5,6,7,8,9,10]</code>，我们需要从中查找<code>7</code>这个数字，二分查找法的查找步骤如下：</p><ul><li>首选选取数组中间的值Mid（如果中间有两个值则可以在二者中任选一个），(1+10)&#x2F;2&#x3D;5.5，这里取Mid&#x3D;5<ul><li>将Mid与需要查找的数字7作比较，结果是Mid&lt;7</li></ul></li><li>那么接下来在[Mid+1&#x3D;6, 10]的区间中取中间值Mid&#x3D;(6+10)&#x2F;2&#x3D;8;<ul><li>将Mid与7作比较，结果是Mid&gt;7</li></ul></li><li>接下来在[6, Mid-1&#x3D;7]的区间中取中间值(6+7)&#x2F;2&#x3D;6.5，这里取Mid&#x3D;6<ul><li>将Mid与7作比较，结果是Mid&lt;7</li></ul></li><li>接下来在[Mid+1&#x3D;7, 7]的区间中取中间值Mid&#x3D;(7+7)&#x2F;2&#x3D;7<ul><li>此时Mid&#x3D;7，查找成功。</li></ul></li></ul><p>由上可以看出我们只进行了4次查找，而利用普通的顺序查找则需要花费7次。不仅如此，当我们查找该数组中的任意一个值时，利用二分查找算法我们都只需要花费4步，即<code>t=LogN</code>（这里的<code>Log</code>的底数为2不为10）。</p><h3 id="Javascript代码实现"><a href="#Javascript代码实现" class="headerlink" title="Javascript代码实现"></a>Javascript代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 建立一个数组</span><br><span class="hljs-keyword">const</span> arr = []<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000</span>;i++)&#123;<br>    arr.<span class="hljs-title function_">push</span>(i)<br>&#125;<br><br><span class="hljs-comment">/* 二分查找算法:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">arr, item</span>)&#123;<br>    <span class="hljs-comment">// 利用两个变量分别指向当前查找范围的上下限索引</span><br>    <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>, high = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 当下限不超过上限时执行以下循环</span><br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>    <span class="hljs-comment">// 利用一个变量保存当前查找范围的中位数</span><br>    <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((low + high) / <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span>(arr[mid] === item)&#123;<br>            <span class="hljs-comment">// 如果当前查找范围的中位数等于需要查找的数，则表示已经查找到了</span><br>            <span class="hljs-keyword">return</span> arr[mid]<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &lt; item)&#123;<br>            <span class="hljs-comment">// 如果当前查找范围的中位数小于需要查找的数，则说明下限小了</span><br>            low = mid + <span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 如果当前查找范围的中位数大于需要查找的数，则说明上限大了</span><br>            high = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 否则未查找到</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx服务器颁发ssl证书</title>
    <link href="/2020/12/15/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A2%81%E5%8F%91ssl%E8%AF%81%E4%B9%A6/"/>
    <url>/2020/12/15/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A2%81%E5%8F%91ssl%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<ol><li><p><a href="https://snapcraft.io/docs/installing-snap-on-centos">安装<code>snap</code></a></p><ul><li><p>Adding EPEL to CentOS 8</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ sudo dnf install epel-release<br>$ sudo dnf upgrade<br></code></pre></td></tr></table></figure></li><li><p>Installing snapd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># With the EPEL repository added to your CentOS installation, simply install the snapd package:</span><br>$ sudo yum install snapd<br><br><span class="hljs-comment"># Once installed, the systemd unit that manages the main snap communication socket needs to be enabled:</span><br>$ sudo systemctl <span class="hljs-built_in">enable</span> --now snapd.socket<br><br><span class="hljs-comment">#To enable classic snap support, enter the following to create a symbolic link between /var/lib/snapd/snap and /snap:</span><br>$ sudo <span class="hljs-built_in">ln</span> -s /var/lib/snapd/snap /snap<br><br><span class="hljs-comment">#Either log out and back in again or restart your system to ensure snap’s paths are updated correctly.</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>Ensure that your version of snapd is up to date</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo snap install core<br>$ sudo snap refresh core<br></code></pre></td></tr></table></figure></li><li><p>Remove any Certbot OS packages</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get remove certbot<br><span class="hljs-comment"># or</span><br>$ sodu dnf remove certbot<br><span class="hljs-comment"># or</span><br>$ sudo yum remove certbot<br></code></pre></td></tr></table></figure></li><li><p>Install Certbot</p><ul><li><p>Run this command on the command line on the machine to install Certbot.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo snap install --classic certbot<br></code></pre></td></tr></table></figure></li><li><p>Execute the following instruction on the command line on the machine to ensure that the <code>certbot</code> command can be run.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">ln</span> -s /snap/bin/certbot /usr/bin/certbot<br></code></pre></td></tr></table></figure></li><li><p>Run this command on the command line on the machine to acknowledge that the installed plugin will have the same <code>classic</code> containment as the Certbot snap.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo snap <span class="hljs-built_in">set</span> certbot trust-plugin-with-root=ok<br><span class="hljs-comment"># If you encounter issues with running Certbot, you may need to follow this step, then the &quot;Install correct DNS plugin&quot; step, again.</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>获取证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ certbot certonly<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>nginx</tag>
      
      <tag>ssl证书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cookie</title>
    <link href="/2020/04/09/Cookie/"/>
    <url>/2020/04/09/Cookie/</url>
    
    <content type="html"><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="Cookie是什么"><a href="#Cookie是什么" class="headerlink" title="Cookie是什么"></a>Cookie是什么</h2><p>HTTP Cookie（也叫Web  Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#HTTP_is_stateless_but_not_sessionless">无状态</a>的HTTP协议记录稳定的状态信息成为了可能。</p><p>Cookie主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p>Cookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销（尤其是在移动环境下）。 </p><h2 id="如何创建Cookie"><a href="#如何创建Cookie" class="headerlink" title="如何创建Cookie"></a>如何创建Cookie</h2><p>当服务器收到HTTP请求时，服务器可以在响应头里面添加一个<code>Set-Cookie</code>选项。浏览器收到响应后通常会保存下Cookie，之后对该服务器每一次请求中都通过<code>Cookie</code>请求头部将Cookie信息发送给服务器。另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p><p>以下是在koa中创建Cookie的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx,next)=&gt;&#123;<br>    <span class="hljs-comment">//创建cookie</span><br>    ctx.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;Hello World&quot;</span>)<br>    <br>    <span class="hljs-comment">//获取cookie</span><br>    ctx.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面的代码创建了一个名为<code>test</code>的cookie，其值为<code>Hello World</code>，在浏览器接收到该响应头时，会自动保存这条cookie记录，并且在下次访问（请求）该页面时自动在请求头中带上这条cookie。</p><p>koa中<code>ctx.cookies.set</code>的第三个参数为一个对于该条cookie的藐视对象，该对象有以下属性：</p><ul><li>maxAge：该条cookie的最长有效时间，毫秒值</li><li>signed：布尔值，指示该cookie是否为签名字符串</li><li>expires：该条cookie的失效时间</li><li>path： 指定了主机下的哪些路径可以接受Cookie</li><li>domain： 指定了哪些主机可以接受Cookie。默认为当前文档的主机（不包含子域名）</li><li>secure：标记为 <code>Secure</code> 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端</li><li>httpOnly：标记为<code>httpOnly</code>的Cookie不能被本地JavaScript脚本调用</li><li>overwrite：是否重写与当前cookie重名的cookie</li><li>sameSite：布尔值或字符串（true：strict，false：lax），指示cookie是否为“相同站点” cookie</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">HTTP cookies</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>浏览器</tag>
      
      <tag>数据存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket</title>
    <link href="/2020/01/06/WebSocket/"/>
    <url>/2020/01/06/WebSocket/</url>
    
    <content type="html"><![CDATA[<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p><code>WebSocket</code>是HTML5的新特性之一，是一种新的网络通信协议</p><p>特点：</p><ul><li>允许服务器主动向客户端发送数据</li><li>基于HTTP协议（握手阶段采用了HTTP）</li><li>数据格式简单，性能开销小，通信效率高</li></ul><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h3><p>目前主流的浏览器都已经支持<code>WebSocket</code>，使用时只需通过<code>WebSocket</code>构造函数即可</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(url[,protocols])<br><span class="hljs-comment">// url WebSocket服务器，例如 ws://127.0.0.1:8888</span><br><span class="hljs-comment">// protocols 一个协议字符串或者一个包含协议字符串的数组。这些字符串用于指定子协议，这样单个服务器可以实现多个WebSocket子协议（例如，您可能希望一台服务器能够根据指定的协议（protocol）处理不同类型的交互）。如果不指定协议字符串，则假定为空字符串。</span><br><br>ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//连接建立成功时执行的函数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connection established&quot;</span>)<br>&#125;<br>ws.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//连接断开时执行的函数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Disconnected&quot;</span>)<br>&#125;<br>ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>) &#123;<br>    <span class="hljs-comment">//收到服务器消息时执行的函数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">data</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>服务器端较浏览器端更为灵活，目前有多种方式实现，这里以NodeJs的一个第三方库<code>ws</code>为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//npm install ws -S</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WS</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ws&#x27;</span>)<br><span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">WS</span>.<span class="hljs-title class_">Server</span>(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">8888</span> &#125;)<br><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">ws, request</span>) &#123;<br>    <span class="hljs-comment">//连接建立时执行的函数</span><br>    ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Welcome!&#x27;</span>)<br>    <span class="hljs-keyword">let</span> ip = request.<span class="hljs-property">connection</span>.<span class="hljs-property">remoteAddress</span><br>    <span class="hljs-keyword">let</span> port = request.<span class="hljs-property">connection</span>.<span class="hljs-property">remotePort</span><br>    ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received message from <span class="hljs-subst">$&#123;ip&#125;</span>:<span class="hljs-subst">$&#123;port&#125;</span> ==&gt; <span class="hljs-subst">$&#123;message&#125;</span>`</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a>WebSocket API</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><table><thead><tr><th align="center">名称</th><th align="center">值</th></tr></thead><tbody><tr><td align="center">WebSocket.CONNECTING</td><td align="center">0</td></tr><tr><td align="center">WebSocket.OPEN</td><td align="center">1</td></tr><tr><td align="center">WebSocket.CLOSING</td><td align="center">2</td></tr><tr><td align="center">WebSocket.CLOSED</td><td align="center">3</td></tr></tbody></table><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><p><code>WebSocket.close([code[,reason]])</code></p><p>关闭当前连接</p><ul><li><code>code</code>，解释连接关闭的原因的<a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes">数字状态码</a>，默认105</li><li><code>reason</code>，自定义的解释字符串，不能超过123字节</li></ul></li><li><p><code>WebSocket.send(data)</code></p><p>向服务器发送数据</p><ul><li><code>data</code>，需要发送的数据，其格式必须是字符串、<code>ArrayBuffer</code>、<code>Blob</code>、<code>ArrayBufferView</code>其中之一</li></ul></li></ol><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li><p><code>WebSocket.binaryType</code>， 返回websocket连接所传输二进制数据的类型</p></li><li><p><code>WebSocket.bufferedAmount</code>，<strong>只读</strong>，未发送到服务器的字节数</p></li><li><p><code>WebSocket.extensions</code>，<strong>只读</strong>，服务器选择的扩展</p></li><li><p><code>WebSocket.protocol</code>，<strong>只读</strong>，服务器选择的下属协议</p></li><li><p><code>WebSocket.readyState</code>，<strong>只读</strong>，当前连接状态</p></li><li><p><code>WebSocket.url</code>，<strong>只读</strong>，WebSocket的绝对路径</p></li><li><p><code>WebSocket.onclose</code>，指定连接关闭的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;WebSocket is closed now.&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><code>WebSocket.onerror</code>，指定连接失败后的回调函数，用法及参数同上</p></li><li><p><code>WebSocket.onmessage</code>，指定当接收到服务器的消息时的回调函数，用法及参数同上</p></li><li><p><code>WebSocket.onopen</code>，指定连接成功后的回调函数，用法及参数同上</p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket教程</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">MDN WebSocket</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>WebSocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器缓存机制</title>
    <link href="/2019/11/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    <url>/2019/11/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><p>浏览器缓存也就是HTTP缓存，其机制是通过http响应头中的相关字段来判断是否启用缓存。浏览器缓存机制有两种：<strong>强制缓存</strong>和<strong>协商缓存</strong></p><p>浏览器缓存机制如下：</p><p><img src="https://camo.githubusercontent.com/951b2de12f363d221a8962039734880f2ba99f44/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f32302f313633376430626331333762323832613f773d39303126683d38313526663d706e6726733d313439323734"></p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>在http响应头中，与强制缓存有关的字段有：<code>Cache-Control</code>和<code>Expires</code>，其中<code>Cache-Control</code>是http1.1中的内容，<code>Expires</code>是http1.0中的内容</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p><code>Cache-Control</code>的值可以是以下字段的组合：</p><table><thead><tr><th align="center">值</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">资源可以被代理服务器缓存</td></tr><tr><td align="center">private</td><td align="center">资源仅客户端可以缓存</td></tr><tr><td align="center">max-age&#x3D;n</td><td align="center">缓存有效时间为n秒</td></tr><tr><td align="center">s-max-age&#x3D;n</td><td align="center">同上，只不过仅适用于代理服务器</td></tr><tr><td align="center">no-store</td><td align="center">不允许缓存</td></tr><tr><td align="center">no-cache</td><td align="center">不允许强制缓存，允许协商缓存</td></tr><tr><td align="center">max-state&#x3D;n</td><td align="center">n秒内，即使缓存资源已过期也使用该缓存</td></tr><tr><td align="center">min-fresh&#x3D;n</td><td align="center">能够容忍的最小新鲜度</td></tr></tbody></table><p>使用<code>Cache-Control</code>的强制缓存流程如下：</p><p><img src="https://media.prod.mdn.mozit.cloud/attachments/2016/08/19/13771/2e3dc2278f2aaa83a695e1c1eca98fc0/HTTPStaleness.png"></p><p>在koa中使用：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs js">ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;max-age:10;private&quot;</span>)<br><span class="hljs-comment">//十秒后资源过期，且仅允许客户端缓存</span><br></code></pre></td></tr></table></figure><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>如果一个响应头中同时存在<code>Cache-Control</code>和<code>Expires</code>，则前者的优先级更高，主要用于兼容不支持<code>Cache-Control</code>的浏览器</p><p>在koa中使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Expires&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + <span class="hljs-number">10000</span>).<span class="hljs-title function_">toGMTString</span>())<br><span class="hljs-comment">//十秒后资源过期</span><br></code></pre></td></tr></table></figure><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>即最后修改时间，由服务器返回给客户端，客户端第二次及以后的请求都会自动加上<code>If-Modified-Since</code>请求头，值为服务器上一次返回的<code>Last-Modified</code>的值，服务端收到后会将该值与所请求文件的最后修改时间作比较，如果相同服务器就会返回304状态码，否则返回最新的资源文件</p><p>在koa中使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-comment">//...</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> filename = path.<span class="hljs-title function_">resolve</span>(__dirname,ctx.<span class="hljs-property">filename</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">stat</span>(filename,<span class="hljs-function">(<span class="hljs-params">err, stat</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(<span class="hljs-number">404</span>)<br>            <span class="hljs-comment">//服务器文件最后修改时间</span><br>        <span class="hljs-keyword">let</span> last = stat.<span class="hljs-property">ctime</span>.<span class="hljs-title function_">toGMTString</span>()<br>            <span class="hljs-comment">//客户端得到的文件最后修改时间</span><br>            <span class="hljs-keyword">let</span> since = ctx.<span class="hljs-property">header</span>[<span class="hljs-string">&#x27;if-modified-since&#x27;</span>]<br>            <span class="hljs-comment">//若 last === since 则表示文件未修改</span><br>            <span class="hljs-keyword">if</span>(last === since)<br>                <span class="hljs-title function_">reject</span>(<span class="hljs-number">304</span>)<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//文件已修改，返回最新修改时间</span><br>                <span class="hljs-title function_">resolve</span>(last)<br>            &#125;<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Last-Modified&quot;</span>, res)<br>        ctx.<span class="hljs-property">body</span> = fs.<span class="hljs-title function_">createReadStream</span>(filename)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(err === <span class="hljs-number">304</span>)<br>            ctx.<span class="hljs-property">status</span> = <span class="hljs-number">304</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            ctx.<span class="hljs-property">status</span> = <span class="hljs-number">404</span><br>            ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;404 Not Found&#x27;</span><br>        &#125;<br>    &#125;)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>()<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>同<code>Last-Modified</code>，也是由服务器返回给客户端，并且在客户端第二次及以后的请求中都会自动携带上<code>If-None-Match</code>请求头，值为上一次服务器返回的<code>ETag</code>的值（这个值是一个表示文件版本信息的字符串，仅在文件内容发生变化时才会更新该值，支持自定义生成），服务器收到该值后便会与当前所请求文件的版本信息作比较，如果相同则返回状态码304，否则返回最新文件</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000009970329">最常被遗忘的Web性能优化：浏览器缓存</a></li><li><a href="https://github.com/ljianshu/Blog/issues/9">页面性能优化办法有哪些</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>缓存机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux服务器上安装并配置MongoDB</title>
    <link href="/2019/11/09/Linux%E4%B8%8A%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEMongoDB/"/>
    <url>/2019/11/09/Linux%E4%B8%8A%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEMongoDB/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux上安装并配置MongoDB"><a href="#Linux上安装并配置MongoDB" class="headerlink" title="Linux上安装并配置MongoDB"></a>Linux上安装并配置MongoDB</h1><p>本文用于测试的linux系统的CentOS6 X64<br>mongoDB版本为4.0.16，Linux下载链接：<a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.16.tgz">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.16.tgz</a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.16.tgz<br></code></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf mongodb-linux-x86_64-4.0.16.tgz<br><span class="hljs-comment"># 将解压后的文件改名为mongodb并移至/usr/local/目录下</span><br><span class="hljs-built_in">mv</span> mongodb-linux-x86_64-4.0.16.tgz /usr/local/mongodb<br><span class="hljs-comment"># 由于该版本为免安装版（其他系统及版本没试过不清楚），可执行文件就在解压后文件中的bin目录下</span><br></code></pre></td></tr></table></figure><h2 id="启动mongodb前的配置"><a href="#启动mongodb前的配置" class="headerlink" title="启动mongodb前的配置"></a>启动mongodb前的配置</h2><h3 id="建立配置文件"><a href="#建立配置文件" class="headerlink" title="建立配置文件"></a>建立配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在mongodb目录中新建conf文件夹，用于存放配置文件</span><br><span class="hljs-built_in">mkdir</span> conf<br><span class="hljs-comment"># 同样新建logs文件夹，用于存放日志文件</span><br><span class="hljs-built_in">mkdir</span> logs<br><span class="hljs-comment"># 在cong目录中新建mongod.conf</span><br><span class="hljs-built_in">cd</span> conf<br><span class="hljs-built_in">touch</span> mongod.conf<br><span class="hljs-comment"># 在配置文件中输入以下内容</span><br><span class="hljs-comment">##port 端口号</span><br>port=23000<br><span class="hljs-comment">##dbpath 数据库存储文件目录</span><br>dbpath=/usr/local/mongo/mongodb/data<br><span class="hljs-comment">##logpath 日志路径</span><br>logpath=/usr/local/mongo/mongodb/logs/mongodb.log<br><span class="hljs-comment">##logappend 日志追加形式  false:重新启动覆盖文件</span><br>logappend=<span class="hljs-literal">true</span><br><span class="hljs-comment">##fork 在后台运行</span><br>fork=<span class="hljs-literal">true</span><br><br><span class="hljs-comment">##设置日志级别</span><br><span class="hljs-comment">##0 - 关闭性能分析，测试环境可以打开，生成环境关闭，对性能有很大影响;</span><br>    <span class="hljs-comment">##1 - 开启慢查询日志，执行时间大于100毫秒的语句</span><br><span class="hljs-comment">##2 - 开启所有操作日志</span><br>profile=1<br></code></pre></td></tr></table></figure><p>更多可配置项详见参考资料</p><h3 id="添加到系统全局环境变量"><a href="#添加到系统全局环境变量" class="headerlink" title="添加到系统全局环境变量"></a>添加到系统全局环境变量</h3><p>添加到全局变量后可以在命令行任何位置使用与mongodb相关的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编辑全局系统环境变量文件</span><br>vim /etc/profile<br><span class="hljs-comment"># 在末尾追加以下内容后保存</span><br><span class="hljs-built_in">export</span> MONGO_PATH=/usr/local/mongodb<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$MONGO_PATH</span>/bin:<span class="hljs-variable">$PATH</span><br><br><span class="hljs-comment">#重新加载环境变量配置文件</span><br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-comment">#没有任何输出则说明加载成功</span><br></code></pre></td></tr></table></figure><h2 id="启动mongoDB服务"><a href="#启动mongoDB服务" class="headerlink" title="启动mongoDB服务"></a>启动mongoDB服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用以下命令启动服务,--config（简写-f）表示利用配置文件启动</span><br>mongod --config /usr/local/mongodb/conf/mongod.conf<br><br><span class="hljs-comment"># 直接在命令行输入mongo即可连接到mongodb</span><br>mongo<br></code></pre></td></tr></table></figure><h2 id="停止MongoDB服务"><a href="#停止MongoDB服务" class="headerlink" title="停止MongoDB服务"></a>停止MongoDB服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首先需要在mongo命令行内，依次执行以下命令</span><br>use admin<br>db.shutdownServer()<br></code></pre></td></tr></table></figure><h2 id="给MongoDB设置密码"><a href="#给MongoDB设置密码" class="headerlink" title="给MongoDB设置密码"></a>给MongoDB设置密码</h2><p>在mongo终端中使用<code>db.createUser(username,password,roles)</code>来创建用户</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-title function_">createUser</span>(<span class="hljs-string">&#x27;test&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>,<span class="hljs-attr">roles</span>:[<span class="hljs-string">&#x27;readWrite&#x27;</span>])<br><span class="hljs-comment">//可设置的权限详见参考资料</span><br></code></pre></td></tr></table></figure><p>使用<code>db.auth(username,password)</code>来验证，输出为1表示成功，为0则失败。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/d8f471bdfa3b">Linux 下安装mongodb，并配置</a></li><li><a href="https://blog.csdn.net/zhu_tianwei/article/details/44261235">MongoDB 通过配置文件启动</a></li><li><a href="https://www.03sec.com/3176.shtml">Mongodb 新版配置文件详解</a></li><li><a href="https://docs.mongodb.com/manual/reference/configuration-options/">配置文件官方文档</a></li><li><a href="https://segmentfault.com/a/1190000015603831">mongodb用户权限管理最全攻略：用户的创建、查看、删除与修改，mongodb入坑之旅</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在NodeJs中操作MongoDB</title>
    <link href="/2019/10/21/NodeJs%E4%B8%8EMongoDb/"/>
    <url>/2019/10/21/NodeJs%E4%B8%8EMongoDb/</url>
    
    <content type="html"><![CDATA[<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">npm i mongodb -S<br></code></pre></td></tr></table></figure><h2 id="链接数据库"><a href="#链接数据库" class="headerlink" title="链接数据库"></a>链接数据库</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MongoClient</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongodb&#x27;</span>).<span class="hljs-property">MongoClient</span><br><span class="hljs-keyword">const</span> url = <span class="hljs-string">&#x27;mongodb://localhost:27017/testdb&#x27;</span><br><br><span class="hljs-title class_">MongoClient</span>.<span class="hljs-title function_">connect</span>(url,&#123;&#125;,<span class="hljs-function">(<span class="hljs-params">err,database</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err)<br>        <span class="hljs-keyword">throw</span> err<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connecting success!&quot;</span>)<br>    databse.<span class="hljs-title function_">close</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="新建集合"><a href="#新建集合" class="headerlink" title="新建集合"></a>新建集合</h2><p>使用<code>createCollection([collection_name],[callback])</code>来创建集合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">MongoClient</span>.<span class="hljs-title function_">connect</span>(url,&#123;&#125;,<span class="hljs-function">(<span class="hljs-params">err,database</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">//连接到test文档</span><br>    <span class="hljs-keyword">let</span> test = database.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    <span class="hljs-comment">//新建集合</span><br>    test.<span class="hljs-title function_">createCollection</span>(<span class="hljs-string">&#x27;first&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)<br>            <span class="hljs-keyword">throw</span> err<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Success!&quot;</span>)<br>        database.<span class="hljs-title function_">close</span>()<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h2><p>使用<code>&lt;collection&gt;.drop([callback])</code>来删除集合</p><p>也可使用<code>&lt;database&gt;.dropCollection([collection_name],[callback])</code>来删除集合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">MongoClient</span>.<span class="hljs-title function_">connect</span>(url,<span class="hljs-function">(<span class="hljs-params">err,database</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err)<br>        <span class="hljs-keyword">throw</span> err<br>    <span class="hljs-keyword">let</span> test = database.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    <span class="hljs-comment">//使用方法一</span><br>    test.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">drop</span>(<span class="hljs-function">(<span class="hljs-params">err,res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)<br>            <span class="hljs-keyword">throw</span> err<br>        <span class="hljs-keyword">if</span>(res == <span class="hljs-literal">true</span>)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Collection Dropped Success!&quot;</span>)<br>        database.<span class="hljs-title function_">close</span>()<br>    &#125;)<br>    <br>    <span class="hljs-comment">//使用方法二</span><br>    test.<span class="hljs-title function_">dropCollection</span>(<span class="hljs-string">&#x27;first&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)<br>            <span class="hljs-keyword">throw</span> err<br>        <span class="hljs-keyword">if</span>(res == <span class="hljs-literal">true</span>)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Collection dropped Success!&quot;</span>)<br>        database.<span class="hljs-title function_">close</span>()<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>使用<code>insertOne([obj],[callback])</code>向集合中插入一条数据</p><p>使用<code>insertMany([arr],callback)</code>向集合中插入多条数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">MongoClient</span>.<span class="hljs-title function_">connect</span>(url,&#123;&#125;,<span class="hljs-function">(<span class="hljs-params">err,database</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err)<br>        <span class="hljs-keyword">throw</span> err<br>    <span class="hljs-keyword">let</span> test = database.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    <span class="hljs-keyword">let</span> obj = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,<br>        <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>    &#125;<br>    test.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">insertOne</span>(obj,<span class="hljs-function">(<span class="hljs-params">err,res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)<br>            <span class="hljs-keyword">throw</span> err<br>        database.<span class="hljs-title function_">close</span>()<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Insert Success!&#x27;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>使用<code>deleteOne([query],[callback])</code>来删除一条数据</p><p>使用<code>deleteMany([query],[callback])</code>来删除多个数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">MongoClient</span>.<span class="hljs-title function_">connect</span>(url,<span class="hljs-function">(<span class="hljs-params">err,database</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err)<br>        <span class="hljs-keyword">throw</span> err<br>    <span class="hljs-keyword">let</span> test = database.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    test.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">deleteOne</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-regexp">/强$/</span>&#125;,<span class="hljs-function">(<span class="hljs-params">err,res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)<br>            <span class="hljs-keyword">throw</span> err<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Delete Success!&quot;</span>)<br>        database.<span class="hljs-title function_">close</span>()<br>    &#125;)<br>    <br>    test.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">deleteMany</span>(&#123;<span class="hljs-attr">gender</span>:<span class="hljs-string">&quot;famale&quot;</span>&#125;,<span class="hljs-function">(<span class="hljs-params">err,res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)<br>            <span class="hljs-keyword">throw</span> err<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Delete Success!&quot;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">result</span>)<br>        database.<span class="hljs-title function_">close</span>()<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>使用<code>updateOne([query],[new_values],[callback])</code>来更新数据</p><p>使用<code>updatemany([query],[new_values],[callback])</code>来更新多个数据</p><ul><li>使用<code>$set</code>，则仅指定的字段会被更新</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">MongoClient</span>.<span class="hljs-title function_">connect</span>(url,<span class="hljs-function">(<span class="hljs-params">err,database</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err)<br>        <span class="hljs-keyword">throw</span> err<br>    <span class="hljs-keyword">let</span> test = database.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    <span class="hljs-comment">//更新一条数据</span><br>    test.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">updateOne</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;猴砸&quot;</span>&#125;,&#123;<span class="hljs-attr">$set</span>:&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;猴大傻&quot;</span>&#125;&#125;,<span class="hljs-function">(<span class="hljs-params">err,res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)<br>            <span class="hljs-keyword">throw</span> err<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">result</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Update Success!&quot;</span>)<br>    &#125;)<br>    <br>    <span class="hljs-comment">//更新多条数据</span><br>    test.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">updateMany</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-regexp">/傻$/</span>&#125;,&#123;<span class="hljs-attr">$set</span>:&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;这下一改全都改了怎么办&quot;</span>&#125;&#125;,<span class="hljs-function">(<span class="hljs-params">err,res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)<br>            <span class="hljs-keyword">throw</span> err<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Update Success!&quot;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">result</span>)<br>        database.<span class="hljs-title function_">close</span>()<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>使用<code>findOne([query_options],[callback])</code>来查找符合条件的第一条数据</p><p>使用<code>find([query_options],[fields]).toArray([callback])</code>来查找符合条件的所有数据</p><ul><li>第一个参数<code>[query_options]</code>为查询条件，其中若条件为字符串则可使用正则表达式</li><li><code>find()</code>的第二个参数<code>[fields]</code>为描述输出结果的应该包含的字段对象</li><li>使用<code>limit([number])</code>来限制返回的文档数量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">MongoClient</span>.<span class="hljs-title function_">connect</span>(url,&#123;&#125;,<span class="hljs-function">(<span class="hljs-params">err,database</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err)<br>        <span class="hljs-keyword">throw</span> err<br>    <span class="hljs-keyword">let</span> test = database.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    <span class="hljs-comment">//findOne()</span><br>    test.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">findOne</span>(&#123;<span class="hljs-attr">age</span>:<span class="hljs-number">21</span>&#125;,<span class="hljs-function">(<span class="hljs-params">err,res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)<br>            <span class="hljs-keyword">throw</span> err<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>        database.<span class="hljs-title function_">close</span>()<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Find Success!&#x27;</span>)<br>    &#125;)<br>    <span class="hljs-comment">//find()</span><br>    <span class="hljs-keyword">let</span> rules = &#123;<br>        <span class="hljs-attr">projection</span>:&#123;<br>            <span class="hljs-attr">_id</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">gender</span>: <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    test.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">find</span>(&#123;<span class="hljs-attr">age</span>:<span class="hljs-number">21</span>&#125;,rules).<span class="hljs-title function_">toArry</span>(<span class="hljs-function">(<span class="hljs-params">err,res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)<br>            <span class="hljs-keyword">throw</span> err<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>        database.<span class="hljs-title function_">close</span>()<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Find Success!&#x27;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="查找并排序"><a href="#查找并排序" class="headerlink" title="查找并排序"></a>查找并排序</h4><p>使用<code>find([query]).sort([sortQuery])</code>来将查找结果进行排序</p><ul><li><code>sort()</code>的第一个参数<code>[sortQuery]</code>为要用来进行排序的字段，1为升序，-1为降序</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">MongoClient</span>.<span class="hljs-title function_">connect</span>(url,<span class="hljs-function">(<span class="hljs-params">err,database</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err)<br>        <span class="hljs-keyword">throw</span> err<br>    <span class="hljs-keyword">let</span> test = database.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    test.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">find</span>(&#123;&#125;).<span class="hljs-title function_">sort</span>(&#123;<span class="hljs-attr">age</span>: <span class="hljs-number">1</span>&#125;).<span class="hljs-title function_">toArray</span>(<span class="hljs-function">(<span class="hljs-params">err,res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)<br>           <span class="hljs-keyword">throw</span> err<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Find Success!&quot;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>        database.<span class="hljs-title function_">colse</span>()<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="MongoDB-Join"><a href="#MongoDB-Join" class="headerlink" title="MongoDB Join"></a>MongoDB Join</h2><p>即将两个集合相互关联起来，虽然mongoDB不是关系型数据库，但可以用这种方式模拟</p><p>例如有以下两个集合：<code>oeders</code>和<code>products</code></p><p><strong>orders</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        _id<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        product_id<span class="hljs-punctuation">:</span> <span class="hljs-number">154</span><span class="hljs-punctuation">,</span><br>        status<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><strong>products</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span> _id<span class="hljs-punctuation">:</span> <span class="hljs-number">154</span><span class="hljs-punctuation">,</span> name<span class="hljs-punctuation">:</span> &#x27;Chocolate Heaven&#x27; <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span> _id<span class="hljs-punctuation">:</span> <span class="hljs-number">155</span><span class="hljs-punctuation">,</span> name<span class="hljs-punctuation">:</span> &#x27;Tasty Lemons&#x27; <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span> _id<span class="hljs-punctuation">:</span> <span class="hljs-number">156</span><span class="hljs-punctuation">,</span> name<span class="hljs-punctuation">:</span> &#x27;Vanilla Dreams&#x27; <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>再使用以下代码：</p><ul><li>使用<code>aggregate([arr_Obj])</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">MongoClient</span>.<span class="hljs-title function_">connect</span>(url,<span class="hljs-function">(<span class="hljs-params">err,database</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err)<br>        <span class="hljs-keyword">throw</span> err<br>    <span class="hljs-keyword">let</span> test = database.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    test.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;orders&#x27;</span>).<span class="hljs-title function_">aggregate</span>([<br>        &#123;<br>            <span class="hljs-attr">$lookup</span>:&#123;<br>                <span class="hljs-attr">from</span>: <span class="hljs-string">&#x27;products&#x27;</span>,<br>                <span class="hljs-attr">localField</span>: <span class="hljs-string">&#x27;product_id&#x27;</span>,<br>                <span class="hljs-attr">foreignField</span>: <span class="hljs-string">&#x27;_id&#x27;</span>,<br>                <span class="hljs-attr">as</span>: <span class="hljs-string">&#x27;oerderdetails&#x27;</span><br>            &#125;<br>        &#125;<br>    ]).<span class="hljs-title function_">toArray</span>(<span class="hljs-function">(<span class="hljs-params">err,res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)<br>            <span class="hljs-keyword">throw</span> err<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res))<br>        database.<span class="hljs-title function_">close</span>()<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面代码输出的结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;product_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">154</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;orderdetails&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">154</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Chocolate Heaven&quot;</span> <span class="hljs-punctuation">&#125;</span> <br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue Router 进阶</title>
    <link href="/2019/10/15/Vue%20Router%20%E8%BF%9B%E9%98%B6/"/>
    <url>/2019/10/15/Vue%20Router%20%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-Router-进阶"><a href="#Vue-Router-进阶" class="headerlink" title="Vue Router 进阶"></a>Vue Router 进阶</h1><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>简单来说就是在路由进行转跳或取消时执行的一系列函数，导航守卫分为三类：全局的，单个路由的，以及组件级的</p><p>需要注意的时，当仅仅只有参数或者查询字符串发生变化时并不会触发导航守卫</p><h3 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h3><p>在Router的实例上进行注册，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<span class="hljs-comment">/*...*/</span>&#125;)<br><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-title function_">next</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>router.beforeEach</code>接收三个参数：</p><ul><li><code>to</code>：即将进入的路由对象（$route）</li><li><code>from</code>：正要离开的路由对象</li><li><code>next</code>：函数，一系列的操作完毕后一定要调用<code>next()</code>来resolve这个导航守卫，否则将不会正确转跳到点击的路由页面。<code>next()</code>还可接收字符串或路由对象作为参数：<ul><li><code>next(false)</code>：中断当前导航</li><li><code>next(str)</code>：中断当前导航，并转跳到字符串（例如’&#x2F;root&#x2F;aa&#x2F;bb’）所表明的路径</li><li><code>next(obj)</code>：中断当前导航，并转跳到obj（*<strong>路由信息对象</strong>）所表明的路径，这个对象可以有<code>replace:true</code>，<code>name:index</code>等额外配置</li><li><code>next(Error)</code>：如果传入的对象是一个Error实例，那么该导航会被终止并将Error对象传入到<code>router.onError()</code>注册过的回调</li></ul></li></ul><h3 id="全局解析守卫"><a href="#全局解析守卫" class="headerlink" title="全局解析守卫"></a>全局解析守卫</h3><p>使用<code>router.beforeResolve</code>注册一个全局解析守卫，这和<code>router.beforeEach</code>类似，区别是在导航被确认之前，<strong>同时在所有组件内守卫和异步路由组件被解析之后</strong>，解析守卫就被调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeResolve</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-title function_">next</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h3><p>使用<code>router.afterEach</code>来注册一个全局后置钩子，和上面两个不同的是，该钩子函数的回调仅有两个参数：<code>to</code>和<code>from</code>，因此这个钩子函数不能更改或中断导航，仅仅在导航完成后触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h3><p>定义路由时，在每个路由对象中使用<code>beforeEnter</code>来定义一个独享守卫，该守卫仅仅在导航进入该路由之前触发，该钩子函数接收三个参数：<code>to</code>，<code>from</code>和<code>next</code>，所以可以在该钩子中修改或中断导航，<strong>在全局前置守卫触发之后调用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-attr">routes</span>:[&#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./home.vue&#x27;</span>),<br>        <span class="hljs-title function_">beforeEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-title function_">next</span>()<br>    &#125;<br>        <span class="hljs-comment">//...</span><br>    &#125;]<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h3><p>在各个组件中使用<code>beforeRouteEnter</code>，<code>beforeRouteUpdate</code>和<code>beofreRouteLeave</code>来定义仅仅在该组件内有效的守卫，这三个钩子都接收三个参数：<code>to</code>，<code>from</code>和<code>next</code></p><ul><li><p><code>beforeRouteEnter</code>：在路由独享守卫触发后调用</p><ul><li><p>不能访问组件实例<code>this</code></p></li><li><p>但是可以通过给<code>next()</code>传递回调，该回调接收该组件实例作为参数</p></li><li><p><strong>仅仅在这个钩子函数中，<code>next()</code>能接收一个回调作为参数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to,form,next</span>)&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-title function_">next</span>(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">//通过vm访问组件实例</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>beforeRouteUpdate</code>：在路由发生变化，但组件被复用的情况下调用（一个带有动态参数的路径 &#x2F;foo&#x2F;:id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候）</p><ul><li>可以访问组件实例<code>this</code></li></ul></li><li><p><code>beofreRouteLeave</code>：导航离开该组件时调用</p><ul><li><p>可以访问组件实例<code>this</code></p></li><li><p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)&#123;<br>    <span class="hljs-keyword">let</span> answer = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;Wanna leave this page?&quot;</span>)<br>    <span class="hljs-keyword">if</span>(answer)<br>        <span class="hljs-title function_">next</span>()<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-title function_">next</span>(<span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol><li>导航被触发</li><li>在将要离开的组件中调用<code>beforeRouteLeave</code></li><li>调用全局的<code>router.beforeEach</code></li><li>在重用的组件中调用<code>beforeRouteUpdate</code></li><li>调用路由配置中的<code>beforeEnter</code></li><li>解析异步路由组件</li><li>在被激活的组件里调用<code>beforeRouteEnter</code></li><li>调用全局的<code>router.beforeResolve</code></li><li>导航被确认</li><li>调用全局的<code>router.afterEach</code></li><li>触发DOM更新</li><li>调用步骤7中传给<code>next()</code>的回调</li></ol><h2 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h2><p>在定义路由对象时，可以在<code>meta</code>字段中定义一些元信息，用于记录当前路由下的组件的一些验证等信息，例如是否需要登录之后才能访问这个路由，并在路由进行转跳前通过一些钩子函数进行检查，例如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//假如用户即将进入一个关于用户个人信息页面的路由</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>)&#123;<br>    <span class="hljs-comment">//当用户点击了进入该页面的链接之后，即将前往的路由对象已经记录在 to 参数中</span><br>    <span class="hljs-comment">//检测 to 对象中的 matched 属性，并遍历其中各个路由记录查找有无需要登录权限的路由</span><br>    <span class="hljs-keyword">if</span>(to.<span class="hljs-property">matched</span>.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-property">meta</span>.<span class="hljs-property">needLogIn</span>))&#123;<br>        <span class="hljs-comment">//检测到有需要登录的路由</span><br>        <span class="hljs-comment">//接下来判断用户是否已经登录</span><br>        <span class="hljs-keyword">if</span>(isLoggedIn)&#123;<br>            <span class="hljs-comment">//已经登录，则直接进入</span><br>            <span class="hljs-title function_">next</span>()<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//用户没有登录，则转跳到登录页面</span><br>            <span class="hljs-title function_">next</span>(&#123;<br>                <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>                <span class="hljs-attr">query</span>: &#123;<br>                    <span class="hljs-comment">//将当前页面的路径传递过去，方便登陆后直接返回该页面</span><br>                    <span class="hljs-attr">redirect</span>: to.<span class="hljs-property">fullPath</span><br>                &#125;<br>            &#125;)<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//没有检测到需要登录的组件，则直接进入</span><br>        <span class="hljs-title function_">next</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a>过渡动效</h2><ol><li><p><strong>给所有组件设置相同的动效</strong>，只需将<code>&lt;router-view&gt;</code>用一个<code>&lt;transition&gt;</code>标签包裹起来，然后再设置动效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>        &lt;transition name=&#x27;fade&#x27;&gt;<br>    &lt;router-view&gt;&lt;/router-view&gt;<br>    &lt;/transition&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>不同的组件拥有不同的动效</strong>，只需在各个组件中自定义各自的动效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;transition name=&#x27;fade&#x27;&gt;<br>    &lt;div&gt;<br>        &lt;!-- ... --&gt;<br>    &lt;/div&gt;<br>    &lt;/transition&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>基于路由动态应用动效</strong>，在父组件中使用<code>watch</code>监听<code>$route</code>的变化，根据即将前往的路由动态改变<code>&lt;trnasition&gt;</code>的<code>name</code>属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>        &lt;transition :name=&#x27;transitionName&#x27;&gt;<br>    &lt;router-view&gt;&lt;/router-view&gt;<br>    &lt;/transition&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>    data()&#123;<br>        return &#123;<br>            transitionName: undefined<br>        &#125;<br>    &#125;,<br>    watch:&#123;<br>        &quot;$route&quot;(to,from)&#123;<br>            if(to.name == &#x27;a&#x27;)<br>                this.transitionName = &#x27;slide&#x27;<br>            else<br>                this.transitionName = &#x27;fade&#x27;<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>两种方式获取数据：导航完成前获取，导航完成后获取</p><ol><li><p>导航完成前获取</p><p>此方法可以在<code>beforeRouteEnter</code>钩子获取数据，并通过该钩子的<code>next()</code>回调中处理数据</p></li><li><p>导航完成后获取</p><p>在组件的<code>created</code>钩子中获取数据</p></li></ol><h2 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h2><p>创建Router实例时，使用<code>scrollBehavior</code>来创建一个控制滚动行为的函数，该函数接收三个参数：<code>to</code>，<code>from</code>和<code>savedPosition</code>，其中<code>savedPosition</code>当且仅当 <code>popstate</code> 导航 (通过浏览器的 前进&#x2F;后退 按钮触发) 时才可用</p><ul><li><p>该函数仅在html5<code>history</code>模式中有效</p></li><li><p>该函数在路由切换时触发</p></li><li><p>该函数返回<code>false</code>可阻止滚动</p></li><li><p>该函数可返回一个包含位置信息的对象，例如：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//仅包含偏移量</span><br>&#123;<br>   <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>   <span class="hljs-attr">y</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">//包含具体元素信息和偏移量</span><br>&#123;<br>       <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>       <span class="hljs-attr">offset</span>: &#123;<span class="hljs-comment">//offset可选</span><br>           <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>           <span class="hljs-attr">y</span>: <span class="hljs-number">0</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="异步滚动"><a href="#异步滚动" class="headerlink" title="异步滚动"></a>异步滚动</h3><p>&#96;&#96;scrollBehavior<code>可返回一个</code>Promise&#96;，在其中返回位置信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">scrollBehavior</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,savedPosition</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(&#123;<br>                <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>                <span class="hljs-attr">y</span>: <span class="hljs-number">0</span><br>            &#125;)<br>        &#125;,<span class="hljs-number">5000</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>更多<a href="https://github.com/vuejs/vue-router/blob/dev/examples/scroll-behavior/app.js">例子</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">Vue Router 进阶</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Vue Router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue Router</title>
    <link href="/2019/10/14/Vue%20Router/"/>
    <url>/2019/10/14/Vue%20Router/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><p>安装依赖：<code>vue-router</code></p></li><li><p>新建router.js文件并编辑：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-comment">//加载插件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-attr">rules</span>: [&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-comment">//路由重定向，当访问路径为 / 时，重定向到 /first</span><br>        <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/first&#x27;</span><br>    &#125;,&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;first&#x27;</span>,<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/first&#x27;</span>,<br>        <span class="hljs-comment">//路由懒加载，仅有当使用该路由时才会加载</span><br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./components/first.vue&#x27;</span>)<br>    &#125;,&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;second&#x27;</span>,<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;./second&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./components/second.vue&#x27;</span>)<br>    &#125;]<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>编辑APP.vue文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>        &lt;!-- router-view标签的作用为展示各个路由 --&gt;<br>        &lt;!-- router-link标签的作用为点击时跳转到相应的路由 --&gt;<br>        &lt;router-view /&gt;<br>        &lt;router-link to=&#x27;/&#x27;&gt;first&lt;/router-link&gt;<br>        &lt;router-link to=&#x27;/second&#x27;&gt;second&lt;/router-link&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>编辑main.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router.js&#x27;</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-comment">//...</span><br>    router,<br>    <span class="hljs-comment">//...</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h2 id="Vue-Router详细使用之API详解"><a href="#Vue-Router详细使用之API详解" class="headerlink" title="Vue Router详细使用之API详解"></a>Vue Router详细使用之API详解</h2><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><h4 id="构造选项"><a href="#构造选项" class="headerlink" title="构造选项"></a>构造选项</h4><p>详情戳这里<a href="https://router.vuejs.org/zh/api/#router-%E6%9E%84%E5%BB%BA%E9%80%89%E9%A1%B9">Router构建选项</a></p><ol><li><p><code>routes</code>，数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">routes</span>: [<br>    <span class="hljs-comment">//...</span><br>    &#123;<br>    <span class="hljs-attr">path</span>: string,<br>component?: <span class="hljs-title class_">Component</span>,<br>name?: string, <span class="hljs-comment">// 命名路由</span><br>components?: &#123; [<span class="hljs-attr">name</span>: string]: <span class="hljs-title class_">Component</span> &#125;, <span class="hljs-comment">// 命名视图组件</span><br>redirect?: string | <span class="hljs-title class_">Location</span> | <span class="hljs-title class_">Function</span>,<br>props?: boolean | <span class="hljs-title class_">Object</span> | <span class="hljs-title class_">Function</span>, <span class="hljs-comment">//给组件传递参数</span><br>alias?: string | <span class="hljs-title class_">Array</span>&lt;string&gt;, <span class="hljs-comment">//相当于给当前路由（path）的子路由设置的别名</span><br>children?: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">RouteConfig</span>&gt;, <span class="hljs-comment">// 嵌套路由</span><br>beforeEnter?: <span class="hljs-function">(<span class="hljs-params">to: Route, <span class="hljs-keyword">from</span>: Route, next: <span class="hljs-built_in">Function</span></span>) =&gt;</span> <span class="hljs-keyword">void</span>,<br>meta?: any,<br><br>        <span class="hljs-comment">// 2.6.0+</span><br>caseSensitive?: boolean, <span class="hljs-comment">// 匹配规则是否大小写敏感？(默认值：false)</span><br>pathToRegexpOptions?: <span class="hljs-title class_">Object</span> <span class="hljs-comment">// 编译正则的选项</span><br>&#125;<br>    <span class="hljs-comment">//...</span><br>]<br></code></pre></td></tr></table></figure><p><strong>注：</strong>关于<code>component</code>与<code>components</code>的区别，若该路由下仅有一个需要展示的组件则使用前者；反之若有多个组件，则用后者，并搭配<code>&lt;router-view&gt;</code>的<code>name</code>属性</p></li><li><p><code>mode</code>，字符串，可选值<code>&quot;hash&quot;,&quot;history&quot;,&quot;abstract&quot;</code></p></li><li><p><code>base</code>，字符串，应用的根路径</p></li><li><p><code>linkActiveClass</code>，字符串，router-link激活时应用的class</p></li><li><p><code>linkExactActiveClass</code>，字符串，router-link默认的精确激活（路由精确匹配）的class</p></li><li><p><code>scrollBehavior</code>，函数，<a href="https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html">详解</a></p></li><li><p><code>parseQuery/stringifyQuery</code>，函数，提供自定义查询字符串的解析&#x2F;反解析函数。覆盖默认行为</p></li><li><p><code>fallback</code>，布尔，当浏览器不支持 <code>history.pushState</code> 控制路由是否应该回退到 <code>hash</code> 模式</p></li></ol><h4 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h4><ol><li><code>router.app</code>，Vue实例，配置了该router的根实例</li><li><code>router.mode</code>，字符串，路由使用的模式</li><li><code>router.currentRoute</code>，route对象，当前路由对应的路由信息对象</li></ol><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>详见<a href="https://router.vuejs.org/zh/api/#router-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">Router实例方法</a></p><ol><li><code>router.beforeEach,router.beforeResolve,router.afterEach</code>，全局导航守卫</li><li><code>router.push,router.replace,router.go,router.back.router.forward</code>，动态导航到一个新的url</li><li><code>router.getMatchedComponents</code>，返回目标或当前路由匹配的组件数组</li><li><code>router.resolve</code>，解析目标路径</li><li><code>router.addRoutes</code>，动态添加路由规则</li><li><code>router.onReady</code>，当一个路由初始化完成时调用传入的回调函数</li><li><code>router.onError</code>，路由导航过程中出错时调用传入的回调函数</li></ol><h3 id="路由对象-route"><a href="#路由对象-route" class="headerlink" title="路由对象 $route"></a>路由对象 $route</h3><p>一个路由对象表示当前激活的路由的状态信息</p><p>以下内容或返回值都为一个route对象：</p><ul><li>组件内<code>this.$route</code></li><li><code>$route</code>观察者回调</li><li>导航守卫的参数<code>to,from</code></li><li><code>scrollBehavior(to,from,savedPosition)</code>的参数<code>to,from</code></li></ul><h4 id="路由对象属性"><a href="#路由对象属性" class="headerlink" title="路由对象属性"></a>路由对象属性</h4><ol><li><code>$route.path</code>，字符串，当前路由的路径</li><li><code>$route.params</code>，对象，路由传参，没有则为空对象</li><li><code>$route.query</code>，对象，URL查询参数</li><li><code>$route.hash</code>，字符串，当前路由的哈希值，没有则为空</li><li><code>$route.fullPath</code>，字符串，包含查询参数和 hash 的完整路径</li><li><code>$route.matched</code>，数组，包含当前路由的所有嵌套路径片段的路由记录</li><li><code>$route.name</code>，当前路由的名字（如果有的话）</li><li><code>$route.redirectedFrom</code>，如果存在重定向，则为重定向来源路由的名字</li></ol><h2 id="lt-router-link-gt-与-lt-router-view-gt"><a href="#lt-router-link-gt-与-lt-router-view-gt" class="headerlink" title="&lt;router-link&gt;与&lt;router-view&gt;"></a>&lt;router-link&gt;与&lt;router-view&gt;</h2><h3 id="lt-router-link-gt"><a href="#lt-router-link-gt" class="headerlink" title="&lt;router-link&gt;"></a>&lt;router-link&gt;</h3><p>*<strong>新增API：</strong><code>v-slot</code></p><p>通过一个作用域插槽暴露底层的定制能力，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;!-- ...... --&gt;<br>&lt;router-link to=&quot;&#123;name:&#x27;test&#x27;&#125;&quot; v-slot=&#x27;&#123;href,route,navigate,isActive,isExactActive&#125;&#x27;&gt;<br>    &lt;a :href=&#x27;href&#x27; :class=&quot;[isActive &amp;&amp; &#x27;link-active&#x27;, isExactActive &amp;&amp; &#x27;exact-active&#x27;]&quot; @click=&#x27;navigate&#x27;&gt;&#123;&#123;route.name&#125;&#125;&lt;/a&gt;<br>    &lt;/router-link&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ul><li><code>href</code>：解析后的 URL。将会作为一个 <code>a</code> 元素的 <code>href</code> attribute</li><li><code>route</code>：解析后的规范化的地址</li><li><code>navigate</code>：触发导航的函数。<strong>会在必要时自动阻止事件</strong>，和 <code>router-link</code> 同理</li><li><code>isActive</code>：如果需要应用激活的class则为 <code>true</code>。允许应用一个任意的 class</li><li><code>isExactActive</code>：如果需要应用精确激活的class则为 <code>true</code>。允许应用一个任意的 class</li></ul><h4 id="router-link标签的属性"><a href="#router-link标签的属性" class="headerlink" title="router-link标签的属性"></a>router-link标签的属性</h4><ol><li><code>to</code>，字符串|对象，目标路由的链接（包括嵌套路由），或者一个描述目标位置的对象。调用了<code>router.push</code></li><li><code>active-class</code>，字符串，当前路由激活时应用的样式</li><li><code>exact</code>，布尔，是否启用路由精确匹配，仅有精确匹配的路由才会被设置2中的样式</li><li><code>exact-active-class</code>，字符串，仅有路由链接精确匹配时才应用该样式（2与3结合的效果）</li><li><code>tag</code>，字符串，设置router-link实际渲染出来的标签</li><li><code>replace</code>，布尔，将路由操作不写入浏览器的History对象中，调用了<code>router.replace</code>而不是<code>router.push</code></li><li><code>append</code>，布尔，在原URL后追加路径|替换原有路径</li><li><code>event</code>，字符串|包含字符串的数组，设置可以触发导航的事件</li></ol><h3 id="lt-router-view-gt"><a href="#lt-router-view-gt" class="headerlink" title="&lt;router-view&gt;"></a>&lt;router-view&gt;</h3><ol><li><p>有且仅有一个属性：<code>name</code>，字符串，如果设置了名称，则会渲染对应的路由配置中 <code>components</code> 下的相应组件</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;<br>&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;<br>&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>//...<br>    const router = new VueRouter(&#123;<br>  routes: [&#123;<br>      path: &#x27;/&#x27;,<br>      components: &#123;<br>        default: Foo,<br>        a: Bar,<br>        b: Baz<br>      &#125;<br>   &#125;]<br>&#125;)<br>    //...<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>&lt;keep-alive&gt;</code>，用于缓存其内部的路由组件，可与<code>&lt;transition&gt;</code>配合使用，此时<code>&lt;transition&gt;</code>在外部</p></li></ol><h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><p>将同一模式的路由都映射到一个组件，例如<code>/user/foo</code>和<code>/user/bar</code></p><p>只需在注册路由时使用”动态路径参数“即可实现，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-attr">routes</span>: [&#123;<br>        <span class="hljs-comment">//动态路径参数，以冒号开头</span><br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/user/:name&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserProfileComponent</span><br>    &#125;]<br>&#125;)<br></code></pre></td></tr></table></figure><p>获取这个参数时可以在组件内使用<code>$route.params.name</code>即可</p><p>也可以设置多段参数路径，例如<code>/user/:name/age/:age</code>，参数获取方式同上</p><p><strong>需要注意的是</strong>因为这两个路由都使用了同一个组件，因此组件会被复用（不会被摧毁），这意味着某些生命周期钩子函数不会再执行，但是可以用<code>watch</code>监听<code>$route</code>某些数据的变化，或者使用<code>beforeRouteUpdate</code>导航守卫</p><h3 id="捕获所有路由"><a href="#捕获所有路由" class="headerlink" title="捕获所有路由"></a>捕获所有路由</h3><p>使用<code>*</code>即可匹配所有路由，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-comment">//匹配所有路由</span><br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span><br>&#125;<br>&#123;<br>    <span class="hljs-comment">//匹配以 &#x27;user-&#x27; 开头的路由</span><br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;user-*&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当使用了<code>*</code>后，<code>$route.params</code>对象中便会自动添加一个<code>pathMatch</code>参数，它包含了通过<code>*</code>被匹配的部分</p><p>除了使用<code>*</code>外，路由匹配也支持正则表达式</p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>使用路由的<code>children</code>属性可以添加多个子路由</p><p>需要注意的时子路由的<code>path</code>属性不能以<code>/</code>开头，因为这会被误认为是根路径（这可能会出现的问题是，虽然页面效果可能会正常，但是浏览器地址栏不正确），但是在<code>router-link</code>的<code>to</code>属性中必须写包括根路径的完整路径</p><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>简单来说就是利用js代码操作路由而不是利用<code>router-link</code>，相关的方法有<code>router.push,router.replace,router.go</code>，<strong>这三种方法都与history对象中的相应方法类似</strong>，下表是两种操作方法在书写上的差别</p><table><thead><tr><th align="center">声明式</th><th align="center">编程式</th></tr></thead><tbody><tr><td align="center">&lt;router-link to&#x3D;”path”&gt;</td><td align="center">router.push(path)</td></tr><tr><td align="center">&lt;router-link to&#x3D;”path” replace&gt;</td><td align="center">router.replace(path)</td></tr></tbody></table><ol><li><p><code>router.push(location,onComplete,onAbort)</code></p><ul><li><p><code>location</code>：字符串|描述地址的对象</p><p>需要注意的是，如果描述地址的对象中同时带有<code>path</code>和<code>params</code>属性，那么后者会被会被忽略掉；而如果同时带有<code>path</code>和<code>query</code>属性，那么二者都能被成功读取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0001</span> &#125;&#125;)<span class="hljs-comment">//params会被忽略，id不能被读取</span><br><br><span class="hljs-keyword">const</span> id = <span class="hljs-number">0001</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">`/user/<span class="hljs-subst">$&#123;id&#125;</span>`</span>&#125;)<span class="hljs-comment">//id能被读取</span><br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0001</span>&#125;&#125;)<span class="hljs-comment">//id能被读取</span><br></code></pre></td></tr></table></figure></li><li><p><code>onComplete</code>,<code>onAbort</code>：回调函数，分别在导航完成时和终止（导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由）时调用，和下面的<code>router.replace</code>意义相同</p></li></ul></li><li><p><code>router.replace(location,onComplete,onAbort)</code></p><p>和<code>router.push</code>类似，但是该方法不会向<code>history</code>对象中添加新的记录，而是替换掉当前记录</p></li><li><p><code>router.go(num)</code></p><ul><li><code>num</code>，数字，可以为负，整数表示前进，负数表示后退</li></ul></li></ol><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>略</p><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><p>利用<code>&lt;router-view&gt;</code>的唯一属性<code>name</code>，在一个路由下展示多个组件，下面是一个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- app.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;profile&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;setting&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,<br>    <span class="hljs-comment">//此处使用components而不是component</span><br>    <span class="hljs-attr">components</span>: &#123;<br>        <span class="hljs-comment">//default组件渲染到没有命名的router-view中</span><br>        <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./home.vue&#x27;</span>),<br>        <span class="hljs-comment">//profile组件渲染到命名为profile的router-view中</span><br>        <span class="hljs-attr">profile</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./profile.vue&#x27;</span>),<br>    <span class="hljs-comment">//seeting组件渲染到命名为setting的router-view中</span><br><span class="hljs-attr">setting</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./setting.vue&#x27;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>一个更为详细的<a href="https://jsfiddle.net/posva/22wgksa3/">例子</a></p><h3 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h3><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>使用<code>redirect</code>属性来为一个路由实现重定向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//...</span><br>&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/home&#x27;</span><br>    <span class="hljs-comment">//访问 / 路径时 重定向到 /home 路径</span><br>&#125;,&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-function"><span class="hljs-params">to</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">//to 当前路由</span><br>        <span class="hljs-comment">//do something</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;/new-route&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>使用<code>alias</code>属性来给当前路由（path）的子路由设置别名，下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-attr">routes</span>: [&#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>        <span class="hljs-attr">alias</span>: <span class="hljs-string">&#x27;home-alias&#x27;</span><br>        <span class="hljs-comment">//此时访问 /home-alias 相当于访问 /home，但是浏览器上会显示 /home-alias</span><br>    &#125;]<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h3><p>使用<code>props</code>属性来为组件传参，可降低组件与对应路由的耦合性，例如下面的例子：</p><p>原路由配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;user/:id&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./user.vue&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>原html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 不使用 props --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; $route.params.id &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h4><p>如果 <code>props</code> 被设置为 <code>true</code>，<code>route.params</code> 将会被设置为组件属性</p><p>使用布尔模式解耦：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./user.vue&#x27;</span>),<br>    <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span><br>&#125;)<br><br><span class="hljs-comment">//如果该路由包含多个命名路由，则需要分别为各个视图设置props</span><br><span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-attr">default</span>: <span class="hljs-function">()=&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./user.vue&#x27;</span>),<br>    <span class="hljs-attr">profile</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./profile.vue&#x27;</span>)<br>&#125;,<br><span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">default</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">profile</span>: <span class="hljs-literal">false</span><br>    <span class="hljs-comment">//default视图能访问到参数而profile视图不能</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h4><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./home.vue&#x27;</span>),<br>    <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;Hello World!&quot;</span><br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>此时组件内能拿到的<code>msg</code>值为<code>Hello World!</code></p><h4 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h4><p>自定义函数返回一个<code>props</code>对象</p><p>更多<a href="https://github.com/vuejs/vue-router/blob/dev/examples/route-props/app.js">高级用法</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Vue Router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中的事件循环（Event Loop）</title>
    <link href="/2019/10/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89/"/>
    <url>/2019/10/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器中的事件循环（Event-Loop）"><a href="#浏览器中的事件循环（Event-Loop）" class="headerlink" title="浏览器中的事件循环（Event Loop）"></a>浏览器中的事件循环（Event Loop）</h1><h2 id="JavaScript运行机制"><a href="#JavaScript运行机制" class="headerlink" title="JavaScript运行机制"></a>JavaScript运行机制</h2><p>JavaScript是一门单线程语言，这意味着在同一时间只能做一件事，这是JavaScript这门语言的特点。虽然多线程可以提高效率，但是JavaScript的单线程与它的用途有关。因为JavaScript这门语言主要运行在浏览器上，主要用途就是与用户进行交互以及操作DOM，如果JavaScript是多线程语言，那么如果在一个线程上JavaScript在DOM的一个节点添加了内容，而在另一个线程又删除了这个节点，这时浏览器该如何判断以以哪个为准呢？</p><p>所以为了避免更多的复杂性，JavaScript从诞生之初就是一门单线程语言，将来也不会改变。</p><p>JavaScript的单线程也就意味着，所有的任务都必须“排队”，只有前一个任务执行完毕了之后，才会开始执行下一个任务，而如果前一个任务执行时间太长，后面的任务也不得不等着。鉴于此，JavaScript的设计者将任务类型分为两种：同步任务和异步任务。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。大致过程如下图所示。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100801.jpg"></p><p>如图，左边是主线程，右边是异步任务队列，对于主线程，所有的同步任务都在这里执行；对于异步任务队列，只有当一个异步任务执行完毕之后，相应的回调函数会被放入到异步任务队列末尾。等到主线程所有的任务执行完毕过后，JavaScript引擎就会读取处于异步任务队列中首位的任务并放入到主线程中执行，如此往复，这个过程就叫事件循环（Event Loop）。</p><h2 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h2><p>所谓的事件循环，简单理解就是JavaScript引擎不断地读取主线程执行栈中的任务，有就执行，没有就进入下一个循环。而难点就在于异步任务队列中的任务进入主线程的时机。</p><p>对于所有的异步任务，可以分为两类：</p><ul><li>宏任务<ul><li>setTimeout</li><li>setInterval</li><li>setImmediate（Node）</li><li>requestAnimationFrame（浏览器）</li><li>I&#x2F;O</li><li>UI rendering（浏览器）</li></ul></li><li>微任务<ul><li>process.nextTick（Node）</li><li>Promise</li><li>Object.observe</li><li>MutationObserver</li></ul></li></ul><p>宏任务在满足执行条件之后，会把相应的回调函数加入到宏队列中，而微任务则会加入到微队列中。本文就浏览器端做主要叙述。下图详细展示了浏览器的事件循环机制：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/5/165a8667bb6e623e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>下面是我个人对于这个过程的理解：</p><ol><li>JavaScript引擎首先执行主线程中的同步任务（上图的stack），等到所有的任务执行完毕之后，此时主线程执行栈为空，进入第二步；<ul><li>在这个过程中，异步任务会在其他线程执行，等到执行完毕之后，就会把相应的回调函数添加到相应的异步任务队列中；</li></ul></li><li>JavaScript引擎读取位于微任务队列（上图中的Microtask Queue）中首位的任务，并放入到主线程执行栈中执行，直到微任务队列为空，进入第三步；<ul><li>在这个过程中如果其他的微任务执行完毕，则相应的回调函数也会被添加的微任务队列末尾；</li><li>如果遇到宏任务，则将相应回调添加到宏任务队列末尾；</li></ul></li><li>JavaScript引擎读取宏任务队列（上图中的Task Queue）中位于首位的任务，并放入到主线程执行栈中执行，在每执行完毕一个任务之后，进入第四步；<ul><li>在此过程中如果遇到了其他异步任务，则同样在适当时机将回调函数添加到微任务或宏任务队列末尾；</li></ul></li><li>JavaScript引擎检查微任务队列，如果微任务队列中有待执行任务，则回到第二步；否则回到第三步；如此往复……</li></ol><p>了解了基本概念，接下来看几个实例：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">5</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure><p>过程解析：</p><ol><li><p>console.log(1)为同步任务，执行并输出1；</p></li><li><p>setTimeout为异步任务， 那么将其回调函数注册后分发到宏任务队列；</p></li><li><p>new Promise为同步任务，立即执行console.log(4)，输出4，then中回调在适当时机被添加到微任务队列；</p></li><li><p>setTimeout在适当时机回调添加到宏任务队列；</p></li><li><p>console.log(7)立即执行，输出7；</p></li><li><p>所有同步任务执行完毕，检查微任务队列，输出5；</p></li><li><p>微任务队列执行完毕，检查宏任务队列，首先执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出2，并把Promise回调添加到微任务队列；</p></li><li><p>微任务队列不为空，执行回调并输出3；</p></li><li><p>微任务队列为空，检查宏任务队列，执行回调输出6；</p></li><li><p>最终结果为：1 4 7 5 2 3 6</p></li></ol><h2 id="事件循环中的-async-和-await"><a href="#事件循环中的-async-和-await" class="headerlink" title="事件循环中的 async 和 await"></a>事件循环中的 async 和 await</h2><p>关于async和await的用法我不打算叙述，具体可以看一下后面的参考资料。</p><p>在一个事件循环中 await 做了什么？</p><p>从字面意思上看await就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。 <strong>实际上await是一个让出线程的标志</strong>。await后面的函数会先执行一遍，然后就会跳出整个async函数来执行后面的本轮循环中的同步代码。等本轮事件循环执行完了之后又会跳回到async函数中等待await后面表达式的返回值，如果返回值为非promise则继续执行async函数后面的代码，否则将返回的promise放入微任务队列。结合具体的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">a1</span> () &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a1 start&#x27;</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">a2</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a1 end&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">a2</span> () &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a2&#x27;</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>&#125;)<br><br><span class="hljs-title function_">a1</span>()<br><br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;promise2.then&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><br>promise2.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise3&#x27;</span>)<br>    &#125;)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure><p>过程解析：</p><ol><li><p>执行到<code>console.log(&quot;script start&quot;)</code>，输出“script start”；</p></li><li><p>setTimeout回调在适当时机放入宏任务队列；</p></li><li><p>Promise.resolve().then回调放入微任务队列；</p></li><li><p>调用函数a1，进入函数内部</p><ol><li>立即执行<code>console.log(&#39;a1 start&#39;)</code>，输出“a1 start”；</li><li>关键字await，立即执行函数a2，进入函数内部；<ol><li>立即执行<code>console.log(&#39;a2&#39;)</code>，输出“a2”，退出函数；</li></ol></li><li>交出线程，执行外部<strong>同步代码</strong>；</li></ol></li><li><p>new Promise立即执行内部同步任务，输出“promise2”；</p></li><li><p>立即执行<code>console.log(&#39;script end&#39;)</code>，输出“script end”；</p></li><li><p>同步代码执行完毕，检查微任务队列，存在一个任务（3）：</p><ol><li><p>执行回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">() =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出“promise1”；</p></li></ol></li><li><p>检查宏任务队列，空，本轮事件循环结束；</p></li><li><p>下一轮事件循环开始之前，回到a1函数内部awiat关键词处，awiat等到结果，继续执行函数a1：</p><ol><li>立即执行<code>console.log(&#39;a1 end&#39;)</code>，输出“a1 end”；</li><li>函数a1执行完毕，退出函数；</li></ol></li><li><p>进入下一个事件循环，promise2.then回调放入微任务队列；</p></li><li><p>检查微任务队列，存在一个任务（9）：</p><ol><li><p>执行第一个回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">(res) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise3&#x27;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行<code>console.log(res)</code>，输出“promise2.then”，并将Promise.resolve().then回调放入微任务队列</p></li><li><p>微任务队列临时增加，所以继续执行下一个回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">() =&gt; &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise3&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出“promise3”，微任务队列执行完毕；</p></li></ol></li><li><p>进入下一事件循环，检查宏任务队列，存在一个任务（2）</p><ol><li><p>执行第一个回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">() =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出“setTimeout”，宏任务队列为空，微任务队列为空；</p></li></ol></li><li><p>执行完毕，最终输出顺序为：</p><blockquote><p>script start<br>a1 start<br>a2<br>promise2<br>script end<br>promise1<br>a1 end<br>promise2.then<br>promise3<br>setTimeout</p></blockquote></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></p></li><li><p><a href="https://juejin.im/post/5b8f76675188255c7c653811">带你彻底弄懂Event Loop</a></p></li><li><p><a href="https://juejin.im/post/5c148ec8e51d4576e83fd836">从event loop到async await来了解事件循环机制</a></p></li><li><p><a href="https://www.cnblogs.com/lpggo/p/8127604.html">async&#x2F;await 执行顺序详解</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>Event Loop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-async</title>
    <link href="/2019/10/08/ES6-async/"/>
    <url>/2019/10/08/ES6-async/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6-async"><a href="#ES6-async" class="headerlink" title="ES6-async"></a>ES6-async</h1><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。<code>async</code>函数对 Generator 函数的改进，体现在以下四点：</p><ul><li><p>内置执行器</p><p><code>async</code>函数的执行，与普通函数一模一样，只要一行</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFn</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-comment">//执行async函数</span><br><span class="hljs-title function_">asyncFn</span>()<br></code></pre></td></tr></table></figure></li><li><p>更好的语义</p><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p></li><li><p>更广的适用性</p><p><code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p></li><li><p>返回值是 Promise </p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p></li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params">time</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>        &#125;,time)<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> msg = <span class="hljs-keyword">await</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-number">1000</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)<br>&#125;<br><span class="hljs-title function_">asyncFn</span>()<br><span class="hljs-comment">//1秒后输出：Hello World!</span><br></code></pre></td></tr></table></figure><p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params">ms</span>)&#123;<br>    <span class="hljs-keyword">let</span> msg = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>        &#125;,ms)<br>    &#125;)<br>    <span class="hljs-keyword">return</span> msg<span class="hljs-comment">//这里的msg是Promise对象，不是resolve的结果</span><br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFn</span>(<span class="hljs-params">ms</span>)&#123;<br>    <span class="hljs-keyword">let</span> msg = <span class="hljs-keyword">await</span> <span class="hljs-title function_">timeout</span>(ms)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)<br>&#125;<br><span class="hljs-title function_">asyncFn</span>(<span class="hljs-number">2000</span>)<br><span class="hljs-comment">//2秒后输出：Hello World!</span><br></code></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="返回Promise对象"><a href="#返回Promise对象" class="headerlink" title="返回Promise对象"></a>返回Promise对象</h3><p><code>async</code>函数返回一个 Promise 对象，并且函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span><br>&#125;<br><span class="hljs-title function_">asyncFn</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)<br>&#125;)<br><span class="hljs-comment">//Hello World!</span><br></code></pre></td></tr></table></figure><p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Error&#x27;</span><br>&#125;<br><span class="hljs-title function_">asyncFn</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err))<br><span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><h3 id="await命令"><a href="#await命令" class="headerlink" title="await命令"></a>await命令</h3><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 等同于</span><br>  <span class="hljs-comment">// return 123;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-number">123</span>;<br>&#125;<br><br><span class="hljs-title function_">f</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v))<br><span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">then</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>        &#125;,<span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> asyncFn = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> msg = <span class="hljs-keyword">await</span> obj<br>    <span class="hljs-title function_">log</span>(msg)<br>&#125;<br><span class="hljs-title function_">asyncFn</span>()<br><span class="hljs-comment">//1秒后输出：Hello World!</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是<strong>因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理</strong>。</p><p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Error&quot;</span>)<br>    <span class="hljs-comment">//下面的代码不会被执行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;Hello&quot;</span>)<br>        &#125;,<span class="hljs-number">1000</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">asyncFn</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err))<br><span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时有两种解决办法：</p><ul><li><p>将可能出错的语句放入try…catch结构中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Error&quot;</span>)<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;message&quot;</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">asyncFn</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br><span class="hljs-comment">//Error</span><br><span class="hljs-comment">//message</span><br></code></pre></td></tr></table></figure></li><li><p>在可能出错的语句后面加上catch方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Error&quot;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err))<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;message&quot;</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">asyncFn</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br><span class="hljs-comment">//Error</span><br><span class="hljs-comment">//message</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><p><code>async</code>函数内部任何错误都会被视为返回的Promise对象被<code>reject</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Error&#x27;</span><br>    &#125;)<br>&#125;<br><span class="hljs-title function_">asyncFn</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err))<br><span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p><code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中，或者在可能出错的Promise对象后面加上<code>catch</code>方法。</p></li><li><p>多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">let</span> [foo, bar] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">getFoo</span>(), <span class="hljs-title function_">getBar</span>()]);<br><br><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">let</span> fooPromise = <span class="hljs-title function_">getFoo</span>();<br><span class="hljs-keyword">let</span> barPromise = <span class="hljs-title function_">getBar</span>();<br><span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">await</span> fooPromise;<br><span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">await</span> barPromise;<br></code></pre></td></tr></table></figure></li><li><p><code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p></li><li><p>async 函数可以保留运行堆栈。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack</title>
    <link href="/2019/09/29/Webpack/"/>
    <url>/2019/09/29/Webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">npm i webpack -D<br>npm i webpack-cli -D<br></code></pre></td></tr></table></figure><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/** webpack.config.js **/</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">mode</span>:<span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;inline-source-map&#x27;</span>,<br>    <span class="hljs-attr">devServer</span>: &#123;<br>        <span class="hljs-attr">contentBase</span>: <span class="hljs-string">&#x27;./dist&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">entry</span>:<span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">output</span>:<span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">module</span>:&#123;<br>        <span class="hljs-attr">rules</span>:[]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>:&#123;&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3><p>配置开发或生产环境，<code>development</code> 或 <code>production</code>。</p><h3 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h3><p><code>inline-source-map</code>: 打包后代码运行出错时映射详细错误信息</p><h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><p>配置热更新相关</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">contentBase</span>: <span class="hljs-string">&#x27;/dist&#x27;</span>,<span class="hljs-comment">//服务文件夹</span><br>    <span class="hljs-attr">historyApiFullback</span>: <span class="hljs-literal">true</span><span class="hljs-comment">//当使用浏览器history模式时防止刷新出错（只返回同一个文件），值可设为对象进行详细设置</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>配置打包入口文件，有两种配置方式。</p><ol><li><p><strong>单入口文件模式</strong></p><p>字符串，入口文件的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">entry</span>:<span class="hljs-string">&quot;./main.js&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>多入口文件模式</strong></p><p>对象，对象的属性为每个入口文件 [name] ，值为每个入口文件的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">entry</span>:&#123;<br>    <span class="hljs-attr">fileOne</span>: <span class="hljs-string">&#x27;./fileOne.js&#x27;</span>,<br>    <span class="hljs-attr">fileTwo</span>: <span class="hljs-string">&#x27;./fileTwo.js&#x27;</span>,<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>配置打包后的文件一些属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">output</span>:&#123;<br>    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-comment">//在引入静态资源时，从根路径开始引入</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;filename.js&#x27;</span>,<span class="hljs-comment">//打包后的文件名</span><br>    <span class="hljs-comment">//如果指定了多个入口文件，为了将打包后的文件相区别，可以在filename属性中嵌入一些关键字眼如[name]，例如filename:&quot;[filename].bundle.js&quot;</span><br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname,<span class="hljs-string">&#x27;dist&#x27;</span>)<span class="hljs-comment">//字符串，打包后文件的路径</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>配置一些 loader 参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>:&#123;<br>    <span class="hljs-attr">rules</span>:[<br>        &#123;<br>            <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.scss$/</span>,<span class="hljs-comment">//给.scss文件应用以下的打包规则</span><br>            <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>,<span class="hljs-string">&#x27;sass-loader&#x27;</span>]<span class="hljs-comment">//.scss文件的打包规则，这几个loader的顺序不能乱，没有则使用 npm 安装</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>配置一些插件，具体<a href="https://webpack.js.org/plugins/">请看这里</a>，按需使用</p><p>常用插件</p><blockquote><p><a href="https://github.com/jantimon/html-webpack-plugin">htmlWebpackPlugin</a></p><p><a href="https://www.npmjs.com/package/clean-webpack-plugin">clean-webpack-plugin</a></p></blockquote><h2 id="在webpack中使用Vue"><a href="#在webpack中使用Vue" class="headerlink" title="在webpack中使用Vue"></a>在webpack中使用Vue</h2><ol><li><p>首先需要安装相应的依赖：<code>vue</code>，<code>vue-loader</code>，<code>vue-template-compiler</code></p></li><li><p>编辑webpack配置文件：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 第一步：引入vue-loader插件 */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">VueLoaderPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue-loader/lib/plugin&#x27;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-attr">module</span>:&#123;<br>        <span class="hljs-comment">/* 第二步：编写规则 */</span><br>        <span class="hljs-attr">rules</span>:[<br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/</span>,<br>            <span class="hljs-attr">ues</span>: [<span class="hljs-string">&#x27;vue-loader&#x27;</span>]<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>:[<br>        <span class="hljs-comment">/* 第三步：实例化插件 */</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueLoaderPlugin</span>()<br>    ]<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="在webpack中使用Sass"><a href="#在webpack中使用Sass" class="headerlink" title="在webpack中使用Sass"></a>在webpack中使用Sass</h2><ol><li><p>安装相应的依赖：<code>style-loader</code>，<code>css-loader</code>，<code>sass-loader</code>，<code>node-sass</code></p></li><li><p>编辑webpack配置文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-attr">module</span>:&#123;<br>        <span class="hljs-attr">rules</span>:[<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.scss$/</span>,<br>                <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>,<span class="hljs-string">&#x27;sass-loader&#x27;</span>]<br>            &#125;<br>        ]<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="在webpack中使用babel"><a href="#在webpack中使用babel" class="headerlink" title="在webpack中使用babel"></a>在webpack中使用babel</h2><ol><li><p>安装需要的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install babel-loader @babel/core @babel/preset-env -S<br><span class="hljs-comment"># babel-loaderbabel-loader</span><br><span class="hljs-comment"># @babel/corebabel核心功能包</span><br><span class="hljs-comment"># @babel/preset-envbabel提供的转换规则</span><br><span class="hljs-comment"># @babel/polyfill为低版本浏览器提供不支持的api</span><br></code></pre></td></tr></table></figure></li><li><p>编辑webpack配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>:&#123;<br>    <span class="hljs-attr">rules</span>:[<br>        &#123;<br>            <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.js$/</span>,<br>            <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/(node_modules|bower_components)/</span>,<span class="hljs-comment">//排除一些文件夹</span><br>            <span class="hljs-attr">use</span>:&#123;<br>            <span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>                <span class="hljs-attr">options</span>:&#123;<br>                    <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]<br>                &#125;<br>            &#125;<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="一个配置文件示例"><a href="#一个配置文件示例" class="headerlink" title="一个配置文件示例"></a>一个配置文件示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 引入一些插件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">VueLoaderPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue-loader/lib/plugin&#x27;</span>)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * webpack安装：</span><br><span class="hljs-comment"> *  npm i webpack -D</span><br><span class="hljs-comment"> *  npm i webpack-cli -D</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">//打包模式：开发环境(development)，线上环境(production)</span><br>    <span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;development&#x27;</span>,<br>    <span class="hljs-comment">//打包后代码运行出错时映射详细错误信息</span><br>    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;inline-source-map&#x27;</span>,<br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 开启热更新 npm i webpack-dev-server -D</span><br><span class="hljs-comment">     *  npx webpack-dev-server --open</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-attr">devServer</span>: &#123;<br>        <span class="hljs-attr">contentBase</span>: <span class="hljs-string">&#x27;./dist&#x27;</span>,<br>        <span class="hljs-attr">historyApiFallback</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//防止history模式刷新出错</span><br>    &#125;,<br>    <span class="hljs-comment">//打包入口文件，相对路径</span><br>    <span class="hljs-comment">// entry:&#x27;./main.js&#x27;,</span><br>    <span class="hljs-attr">entry</span>:&#123;<br>        <span class="hljs-attr">one</span>: <span class="hljs-string">&#x27;./a.js&#x27;</span>,<br>        <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;./main.js&#x27;</span><br>    &#125;,<br>    <span class="hljs-comment">//打包出口文件配置</span><br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-comment">//统一资源引用根路径</span><br>        <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-comment">//文件名</span><br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].bundle.js&#x27;</span>,<br>        <span class="hljs-comment">//文件路径</span><br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname,<span class="hljs-string">&#x27;dist&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-comment">//插件</span><br>    <span class="hljs-attr">plugins</span>:[<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>            <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;index.html&#x27;</span>,<br>            <span class="hljs-attr">title</span>:<span class="hljs-string">&quot;摩西摩西&quot;</span>,<br>            <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;./src/template.html&quot;</span><br>        &#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueLoaderPlugin</span>()<br>    ],<br>    <span class="hljs-comment">//模块</span><br>    <span class="hljs-attr">module</span>:&#123;<br>        <span class="hljs-attr">rules</span>:[<br>            &#123;<br>              <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/</span>,<br>                <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;vue-loader&#x27;</span>]<br>            &#125;,<br>            &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 处理文件名后缀为.scss 的文件</span><br><span class="hljs-comment">                 *  npm i style-loader css-loader sass-loader node-sass -D</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.scss$/</span>,<br>                <span class="hljs-comment">//用以下 loader 处理，顺序不能换</span><br>                <span class="hljs-attr">use</span>:[<span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>,<span class="hljs-string">&#x27;sass-loader&#x27;</span>]<br>            &#125;,<br>            &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 处理图像</span><br><span class="hljs-comment">                 * npm i file-loader -D</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.(png|jpg)$/</span>,<br>                <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;file-loader&#x27;</span>]<br>            &#125;,<br>            &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 字体处理</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,<br>                <span class="hljs-attr">use</span>:<span class="hljs-string">&#x27;file-loader&#x27;</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.js$/</span>,<br>                <span class="hljs-comment">//排除node包文件夹</span><br>                <span class="hljs-attr">exclude</span>:<span class="hljs-regexp">/node_modules/</span>,<br>                <span class="hljs-attr">use</span>:&#123;<br>                    <span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>                    <span class="hljs-attr">options</span>:&#123;<br>                        <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]<br>                    &#125;<br>                &#125;<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.webpackjs.com/guides/getting-started/">webpack官方文档</a></p></li><li><p><a href="https://www.cnblogs.com/EricZLin/p/9409235.html">在webpack中使用babel</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webpack</tag>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP简单整理</title>
    <link href="/2019/09/28/HTTP%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/"/>
    <url>/2019/09/28/HTTP%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>HTTP是超文本传输协议（Hyper Text Transfer Protocol）的简称，是用于从万维网服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP协议工作于客户端–服务器架构（C&#x2F;S）上，客户端通过URL向服务端发送所有请求。</p><p><strong>关于HTTP的三点注意事项</strong></p><ul><li>HTTP是无连接的<ul><li>每次连接只处理一个请求。服务器处理完请求并收到答应后即断开连接。</li></ul></li><li>HTTP是媒体独立的<ul><li>任何类型的数据都可以通过HTTP协议进行传输。数据类型取决于MIME Type，说明该资源的媒体类型，通常由Web服务器通过Content-Type告知浏览器。</li></ul></li><li>HTTP是无状态的<ul><li>对于事务处理没有记忆能力，如果后续处理需要之前的数据，则该数据必须重新上传。</li></ul></li></ul><h2 id="HTTP消息结构"><a href="#HTTP消息结构" class="headerlink" title="HTTP消息结构"></a>HTTP消息结构</h2><p>客户端请求方式总共有八种：</p><ul><li>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以通过向服务器发送“*”的请求来测试服务器性能。</li><li>HEAD：向服务器索要与GET请求相一致的响应，但只返回头部信息，不返回整个响应消息。</li><li><strong>GET</strong>：向特定的资源发起请求。</li><li><strong>POST</strong>：向指定资源提交数据进行处理，数据包含在请求体中。</li><li>PUT：向指定资源路径上传内容。</li><li>DELETE：请求删除指定资源位置的内容。</li><li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li><li>CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。</li></ul><p>虽然请求方式有八种之多，但常用的也就GET和POST，其他请求都可以通过这两种请求来间接实现。</p><h3 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h3><p>包括四个部分：</p><ul><li>请求行</li><li>请求头部</li><li>空行</li><li>请求数据</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png" alt="请求消息示意图"></p><h3 id="服务端响应消息"><a href="#服务端响应消息" class="headerlink" title="服务端响应消息"></a>服务端响应消息</h3><p>包括四个部分：</p><ul><li>状态行</li><li>响应头部</li><li>空行</li><li>响应数据</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/httpmessage.jpg" alt="响应消息示意图"></p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>HTTP请求状态码共有五种：</p><ol><li>1XX    请求收到，继续处理</li><li>2XX    请求被成功提交</li><li>3XX    重定向</li><li>4XX    请求出错，妨碍服务器的处理</li><li>5XX    服务器处理请求时遇到错误</li></ol><h3 id="常见的HTTP状态码"><a href="#常见的HTTP状态码" class="headerlink" title="常见的HTTP状态码"></a>常见的HTTP状态码</h3><h4 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h4><ul><li><strong>100</strong>    服务器收到请求s的一部分，请求者应当继续发送。</li></ul><h4 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h4><ul><li><strong>200</strong>    服务器成功处理了请求</li></ul><h4 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h4><ul><li><strong>301</strong>    浏览器被永久重定向到另外一个在Location消息头中指定的URL</li><li><strong>302</strong>    表示浏览器暂时重定向到另外一个在Location消息头中指定的URL</li><li><strong>304</strong>    自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容</li></ul><h4 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h4><ul><li><strong>400</strong>    语义错误，请求无法被服务器理解。或者请求参数有误</li><li><strong>403</strong>    客户请求的资源被禁止访问</li><li><strong>404</strong>    客户请求的资源不存在</li><li><strong>405</strong>    请求方法不被允许</li></ul><h4 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h4><ul><li><strong>500</strong>    服务器遇到错误，无法完成请求</li><li><strong>501</strong>    服务器不具备完成请求的功能</li></ul><h3 id="HTTP协议无状态、短连接以及长连接"><a href="#HTTP协议无状态、短连接以及长连接" class="headerlink" title="HTTP协议无状态、短连接以及长连接"></a>HTTP协议无状态、短连接以及长连接</h3><h4 id="HTTP协议是无状态的"><a href="#HTTP协议是无状态的" class="headerlink" title="HTTP协议是无状态的"></a>HTTP协议是无状态的</h4><p>指协议对于事物处理没有记忆能力，服务器不知道客户端的状态。打开一个服务器上的网页和上次打开这个网页之间没有任何联系。</p><h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>客户端每次和服务器进行一次HTTP操作就建立一次链接，任务结束就断开连接。例如浏览器解析HTML页面时每遇到一个web资源就建立一个HTTP会话。</p><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>HTTP&#x2F;1.1起默认使用长连接，使用长连接的HTTP协议会在响应头中加入connection:keep-alive;<br>在使用长连接的情况下，当一个网页打开后，服务器与浏览器之间用于传输HTTP数据的TCP连接不会断开，而是会等待一段时间，如果浏览器再次请求服务器，则会继续使用当前这条连接。</p><p>HTTP协议的长连接和短连接其本质就是TCP协议的长连接和短连接。</p><h2 id="HTTP2-0与HTTP1-X的区别"><a href="#HTTP2-0与HTTP1-X的区别" class="headerlink" title="HTTP2.0与HTTP1.X的区别"></a>HTTP2.0与HTTP1.X的区别</h2><p>最大的特点就是访问速度更快</p><ul><li><strong>二进制格式</strong></li><li><strong>多路复用：</strong>允许在一次http链接中发起多次request</li><li><strong>头部压缩</strong></li><li><strong>服务端推送</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中不同数据类型之间的运算和比较</title>
    <link href="/2019/09/25/JavaScript%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97%E5%92%8C%E6%AF%94%E8%BE%83/"/>
    <url>/2019/09/25/JavaScript%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97%E5%92%8C%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript中不同数据类型之间的运算和比较"><a href="#JavaScript中不同数据类型之间的运算和比较" class="headerlink" title="JavaScript中不同数据类型之间的运算和比较"></a>JavaScript中不同数据类型之间的运算和比较</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先来看几个例子</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+&#123;&#125;)<span class="hljs-comment">//NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; == &#123;&#125;)<span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; == <span class="hljs-string">&#x27;test&#x27;</span>)<span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; === <span class="hljs-string">&#x27;test&#x27;</span>)<span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; == <span class="hljs-string">&#x27;[object Object]&#x27;</span>)<span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] == ![])<span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>] == <span class="hljs-string">&#x27;a,b&#x27;</span>)<span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; == <span class="hljs-number">1</span>)<span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-number">1</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>上面的部分结果刚开始看起来我是很诧异的，直到弄清楚了其中的规律才恍然大悟！</p><p>在开始之前，我们有必要知道js中的<strong>原始数据类型</strong>（Primitive value）：</p><blockquote><p>null<br>undefined<br>number<br>string<br>boolean<br>symbol        (ES6新增，还没去了解过)</p></blockquote><h2 id="JS中不同数据类型比较原理"><a href="#JS中不同数据类型比较原理" class="headerlink" title="JS中不同数据类型比较原理"></a>JS中不同数据类型比较原理</h2><p>在编写JS代码时，我们或多或少会遇到一些与预期不符的情况出现，好吧，我承认是我太菜了。。。</p><p>话不多说，先上转换规则</p><table><thead><tr><th align="center">比较类型一</th><th align="center">比较类型二</th><th align="center">比较规则</th></tr></thead><tbody><tr><td align="center">对象</td><td align="center">对象</td><td align="center">比较是不是同一个内存地址</td></tr><tr><td align="center">对象</td><td align="center">字符串</td><td align="center">对象先转为字符串，在和字符串进行比较</td></tr><tr><td align="center">对象</td><td align="center">布尔</td><td align="center">两边都要先转为数值，false为0，true为1，对象需要先隐式调用toString()，在用toNumber()转换为数值</td></tr><tr><td align="center">数字</td><td align="center">布尔</td><td align="center">布尔转为数值，再与数值作比较</td></tr><tr><td align="center">数字</td><td align="center">字符串</td><td align="center">对字符串使用Number()，再与数值作比较</td></tr><tr><td align="center">布尔</td><td align="center">数字&#x2F;字符串</td><td align="center">都转为数值作比较</td></tr><tr><td align="center">null</td><td align="center">undefined</td><td align="center">true</td></tr><tr><td align="center">null&#x2F;undefined</td><td align="center">其他</td><td align="center">false</td></tr><tr><td align="center">NaN</td><td align="center">NaN</td><td align="center">false</td></tr></tbody></table><p><strong>可以这么记：对象  —&gt;  字符串  —&gt;  数字  &lt;—  布尔</strong>。当比较的两者数据类型不同时，数据类型的转换偏向于箭头指向一方。</p><p>补充一点说明：<strong>除了“”（空字符串）、0、NaN、null、undefined、false转为Boolean类型为false，其他全部为true</strong></p><p>知道了这些原理，开头举的作比较的例子也就很简单去理解了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#125; == &#123;&#125;<span class="hljs-comment">//都是临时创建的对象，地址不同，false</span><br>&#123;&#125; == <span class="hljs-string">&#x27;test&#x27;</span><span class="hljs-comment">//[object Object]&#x27; == &#x27;test&#x27;  =&gt;  false</span><br>&#123;&#125; == <span class="hljs-string">&#x27;[object Object]&#x27;</span><span class="hljs-comment">//&#x27;[object Object]&#x27; == &#x27;[object Object]&#x27;  =&gt;  true</span><br>[] == ![]<span class="hljs-comment">//[] == !true  =&gt;  [] == false=&gt;  0 == 0  =&gt;  true</span><br>[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>] == <span class="hljs-string">&#x27;a,b&#x27;</span><span class="hljs-comment">//&#x27;a,b&#x27; == &#x27;a,b&#x27;  =&gt;  true</span><br>&#123;&#125; == <span class="hljs-number">1</span><span class="hljs-comment">//toNumber(&#x27;[object Object]&#x27;) == 1  =&gt; NaN == 1  =&gt;  false</span><br><span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-number">1</span><span class="hljs-comment">// toNumber(&#x27;1&#x27;) == 1  =&gt;  1 == 1  =&gt;  true</span><br></code></pre></td></tr></table></figure><p>这里需要补充的一点是，<strong>如果在比较运算中出现了!（感叹号），那么系统首先要处理这部分数据</strong>，例如上面的[] &#x3D;&#x3D; ![]，具体做法就是先将感叹号后面的数据转为布尔类型，再取反。</p><p>但是，相信许多小伙伴依然有许多不明白的 地方，比如例子中的 {} 是如何转换为 ‘[object Object]’，而 [‘a’,’b’] 又是如何转换为 ‘a,b’ 的，不急，且看我慢慢道来。</p><h2 id="JS中对象的类型转换"><a href="#JS中对象的类型转换" class="headerlink" title="JS中对象的类型转换"></a>JS中对象的类型转换</h2><p>开始之前，我再举几个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<span class="hljs-comment">//&#123;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+obj)<span class="hljs-comment">//NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> + obj)<span class="hljs-comment">//1[object Object]</span><br><span class="hljs-title function_">alert</span>(obj)<span class="hljs-comment">//[object Object]</span><br></code></pre></td></tr></table></figure><p>这里涉及到两个问题</p><ol><li><p>一个是在 “+” 运算符面前，不同的数据类型应该作何转换</p></li><li><p>另一个是 obj 这个对象到底是如何转换为 ‘[object Object]’ 的</p></li></ol><p>首先看第一个问题，其实很简单，只有两种情况：</p><ul><li><p>数值相加</p></li><li><p>字符串相加</p></li><li><p>其他的情况下都会被强制转为这两种数据类型</p></li></ul><p>关于第二个问题，下面就是我个人总结的内容。</p><h3 id="JS中对象类型转换机制"><a href="#JS中对象类型转换机制" class="headerlink" title="JS中对象类型转换机制"></a>JS中对象类型转换机制</h3><p>在JS中存在两种大类数据类型，一种是原始数据类型，另一种是复合数据类型，也就是我们所熟悉的对象。那么对象是如何进行类型转换的呢？</p><p>结论是系统默认调用了对象的内置方法toString() 和 valueOf()。</p><p>问题是我们怎么去判断是不是调用了这两个方法呢，为了测试，我们可以对Object对象的自带这两个方法进行重写，也可以新建一个对象，在新对象里面创建这两个方法。下面看测试代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用了toString 方法&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;,<br>    <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用了 valueOf 方法&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">valueOf</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<br><span class="hljs-comment">//仅仅输出 obj 对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+obj)<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">调用了 valueOf 方法</span><br><span class="hljs-comment">调用了 toString 方法</span><br><span class="hljs-comment">NaN</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> + obj)<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">调用了 valueOf 方法</span><br><span class="hljs-comment">调用了 toString 方法</span><br><span class="hljs-comment">1[object Object]</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title function_">alert</span>(obj)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">调用了toString 方法</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>现在知道了对象的数据类型转换的基本机制，但是还有个问题，<strong>在什么情况下只调用toString()，在什么情况下只调用valueOf()，又在什么情况下两个都调用呢？</strong></p><p>这里就涉及到了JS中的隐式类型转换了，以及另外的一个函数 toPrimitive()，这个函数在js内部视情况自动执行，开发者不能直接调用。</p><p><strong>toPrimitive(input [, preferredType])</strong><br>这个函数的作用是将输入的值 input 转换为原始数据类型，第二个参数要么是string要么是number，如果不填则默认为number（除了Date对象为string）。<br>如果传入的preferrdType为number，则该函数这样执行：</p><ol><li>如果 input 值为原始类型，则返回input。否则继续</li><li>调用input.valueOf()，如果结果为原始类型，则返回该结果。否则继续</li><li>调用input.toString()，如果结果为原始类型，则返回该结果。否则继续</li><li>抛出异常 TypeError</li></ol><p>如果传入的preferredType为string，则该函数这样执行：</p><ol><li>如果 input 值为原始类型，则返回input。否则继续</li><li>调用input.toString()，如果结果为原始类型，则返回该结果。否则继续</li><li>调用input.valueOf()，如果结果为原始类型，则返回该结果。否则继续</li><li>抛出异常 TypeError</li></ol><p>可见只是调用toString() 和 valueOf() 方法的顺序不同。</p><p>这里又得补充一句<strong>由于toPrimitive在js内部自动执行，所以第二个参数是视情况而定的，具体要看当前执行的语句的情况进行判断，</strong>例如当进行加号运算时，js期望的数据类型是number，所以如果涉及到类型转换时，toPrimitive的第二个参数就是number。</p><p>再回到开始提出的问题上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>] == <span class="hljs-string">&#x27;a,b&#x27;</span><span class="hljs-comment">//&#x27;a,b&#x27; == &#x27;a,b&#x27;  =&gt;  true</span><br>&#123;&#125; == <span class="hljs-number">1</span><span class="hljs-comment">//toNumber(&#x27;[object Object]&#x27;) == 1  =&gt; NaN == 1  =&gt;  false</span><br></code></pre></td></tr></table></figure><p>​    <strong>{} 是如何转换为 ‘[object Object]’，而 [‘a’,’b’] 又是如何转换为 ‘a,b’ 的？</strong></p><p>第一个：</p><ul><li>对象和字符串比较，首先将对象隐式转换为字符串<ul><li>隐式转换，调用toPrimitive()，preferredType默认为number</li></ul></li></ul><p>第二个：</p><ul><li>对象和数字比较，首先将对象转为字符串，再将结果转为数字隐式转换<ul><li>隐式转换对象转字符串，调用toPrimitive()，preferredType默认为number</li><li>隐式转换字符串转数字，调用toNumber()</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在不是人为的影响下，涉及到类型转换最多的就是数据之间的比较了，这种类型转换时js内部自动帮我们完成的，隐式转换涉及到的函数有：</p><ul><li>ToPrimitive ( input [ , PreferredType ] )</li><li>ToBoolean ( argument )</li><li>ToNumber ( argument )</li><li>ToString ( argument )        *这个函数不是我们常用的toString()</li></ul><p>这些函数都是js内部的函数，开发者不能直接调用，具体的调用要看执行的代码语句的上下文环境，例如在if语句中用于条件判断的语句，js的期望数据类型是Boolean类型，所以如果不是Boolean类型的数据，js会自动帮我们调用ToBoolean()方法将语句转换为布尔值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://blog.csdn.net/wulove52/article/details/84972152">JS中不同类型作比较的规律 （比较运算符）</a></p></li><li><p><a href="https://stackoverflow.com/questions/2485632/valueof-vs-tostring-in-javascript">valueOf() vs. toString() in Javascript</a></p></li><li><p><a href="https://www.zhuwenlong.com/blog/article/5534ec4efd9753d106000002">JavaScript 对象转换,toString,valueOf</a></p></li><li><p><a href="https://www.jianshu.com/p/b161aeecb6d6">彻底理解js中的数据类型与类型转换</a></p></li><li><p><a href="https://www.cnblogs.com/yangguoe/p/8465092.html">JS的类型转换，强制转换和隐式转换</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据类型转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解浏览器工作原理</title>
    <link href="/2019/09/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2019/09/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h1><h1 id="了解浏览器工作原理"><a href="#了解浏览器工作原理" class="headerlink" title="了解浏览器工作原理"></a>了解浏览器工作原理</h1><p>简单来说，浏览器的作用就是将用户输入的URL网址以图文的形式展示给用户，在网络条件良好的情况下，这个过程往往在极短的时间内发生，看似简单的流程实则比我们想象的复杂的多。</p><h2 id="从用户键入URL地址到页面渲染"><a href="#从用户键入URL地址到页面渲染" class="headerlink" title="从用户键入URL地址到页面渲染"></a>从用户键入URL地址到页面渲染</h2><h3 id="一、域名解析"><a href="#一、域名解析" class="headerlink" title="一、域名解析"></a>一、域名解析</h3><ol><li>浏览器首先会查找自身缓存，如果有该域名记录，则直接返回IP地址；</li><li>浏览器查找操作系统缓存</li><li>浏览器查找路由器缓存</li><li>浏览器查找ISP服务器</li><li>浏览器查找根域名服务器（如.com)，进行递归查询</li></ol><h3 id="二、TCP三次握手"><a href="#二、TCP三次握手" class="headerlink" title="二、TCP三次握手"></a>二、TCP三次握手</h3><ol><li>浏览器向服务器发送一个带<strong>SYN&#x3D;1，Seq&#x3D;X</strong>的数据包到服务器</li><li>服务器收到数据包，并返回一个带<strong>SYN&#x3D;1，ACK&#x3D;X+1，Seq&#x3D;Y</strong>的响应包回应确认信息</li><li>客户端收到响应信息再次回复一个带<strong>ACK&#x3D;Y+1，ACK&#x3D;Seq&#x3D;Z</strong>的数据包，至此握手结束</li></ol><p><strong>需要三次握手的原因：</strong>为了防止已失效的连接请求报文段突然又回传到了服务器</p><h3 id="三、浏览器发送HTTP请求"><a href="#三、浏览器发送HTTP请求" class="headerlink" title="三、浏览器发送HTTP请求"></a>三、浏览器发送HTTP请求</h3><p>一次HTTP请求由<strong>请求行</strong>，<strong>请求头</strong>和<strong>请求体</strong>三部分组成</p><ul><li><p>请求行包括请求方法，URL，协议版本</p><ul><li>请求方法：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE</li><li>URL：scheme:&#x2F;&#x2F;host.domain:port&#x2F;path&#x2F;filename</li><li>协议版本：即HTTP版本号</li></ul><p>例如：<code>GET /about/ HTTP/1.1</code></p></li><li><p>请求头由一些键值对组成</p></li><li><p>请求体包含一些额外的请求参数，且并不是所有的请求都有请求体</p></li></ul><h3 id="四、服务器处理请求并返回信息"><a href="#四、服务器处理请求并返回信息" class="headerlink" title="四、服务器处理请求并返回信息"></a>四、服务器处理请求并返回信息</h3><p>响应报文由<strong>响应行</strong>，<strong>响应头</strong>和<strong>响应主体</strong>三部分</p><ul><li>相应行包括协议版本，状态码，状态码描述</li><li>响应头同请求头，由一些键值对组成</li><li>响应体包含返回数据</li></ul><h3 id="五、浏览器解析并渲染页面"><a href="#五、浏览器解析并渲染页面" class="headerlink" title="五、浏览器解析并渲染页面"></a>五、浏览器解析并渲染页面</h3><ol><li>根据HTML生成DOM树</li><li>根据CSS生成CSS规则树</li><li>结合DOM树和CSS规则树生成渲染树</li><li>根据渲染树计算每一个节点的信息</li><li>根据计算好的信息绘制页面</li></ol><h3 id="六、断开TCP连接"><a href="#六、断开TCP连接" class="headerlink" title="六、断开TCP连接"></a>六、断开TCP连接</h3><p>当浏览器与服务器双方数据都传送完毕之后便会断开TCP连接，这个过程可以理解为四次挥手</p><ul><li>发起方发送一个FIN报文<strong>FIN&#x3D;1，Seq&#x3D;u</strong>，并停止发送数据，进入<strong>FIN_WAIT1</strong>状态</li><li>被动方收到FIN报文，并回复一条确认报文<strong>ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v</strong>，被动方进入<strong>CLOSE_WAIT</strong>状态；发起方收到后进入<strong>FIN_WAIT2</strong>状态</li><li>被动方如果准备好断开连接，便向发起方发送一条FIN报文<strong>FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1</strong>，被动方进入<strong>LAST_ACK</strong>状态</li><li>发起方收到FIN报文之后，回复一条确认报文<strong>ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1</strong>，发起方进入<strong>TIME_WAIT</strong>状态，经过<strong>2MSL</strong>之后，发起方进入<strong>CLOSED</strong>状态</li></ul><h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><p>（以下内容摘自<a href="https://www.cnblogs.com/Peng2014/p/4687218.html">浏览器渲染页面原理</a>）</p><blockquote><ol><li><p>用户输入网址（假设是个 HTML 页面，第一次访问，无缓存情况），浏览器向服务器发出HTTP请求，服务器返回 HTML 文件； <strong>（善用缓存，减少HTTP请求，减轻服务器压力）</strong></p></li><li><p>浏览器载入 HTML 代码，发现 head 内有一个 link 引用外部 CSS 文件,则浏览器立即发送CSS文件请求，获取浏览器返回的CSS文件；  <strong>（CSS文件合并，减少HTTP请求）</strong></p></li><li><p>浏览器继续载入 HTML 中 body 部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了；                              <strong>（CSS文件需要放置最上面，避免网页重新渲染）</strong></p></li><li><p>浏览器在代码中发现一个 img 标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；    <strong>（图片文件合并，减少HTTP请求）</strong></p></li><li><p>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；   <strong>（最好图片都设置尺寸，避免重新渲染）</strong></p></li><li><p>浏览器发现了一个包含一行 JavaScript 代码的 script 标签，会立即运行该js代码；              <strong>（script最好放置页面最下面）</strong></p></li><li><p>js脚本执行了语句，它令浏览器隐藏掉代码中的某个 div,突然就少了一个元素，浏览器不得不重新渲染这部分代码；   <strong>（页面初始化样式不要使用js控制）</strong></p></li><li><p>终于等到了 &#x2F;html 的到来，浏览器泪流满面……</p></li><li><p>等等，还没完，用户点了一下界面中的“换肤”按钮，JavaScript 让浏览器换了一下 link 标签的 CSS 路径；</p></li><li><p>浏览器召集了在座的各位 div span ul li 们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</p></li></ol></blockquote><h2 id="影像页面渲染速度的主要因素——回流和重绘："><a href="#影像页面渲染速度的主要因素——回流和重绘：" class="headerlink" title="影像页面渲染速度的主要因素——回流和重绘："></a>影像页面渲染速度的主要因素——回流和重绘：</h2><h3 id="回流（reflow）"><a href="#回流（reflow）" class="headerlink" title="回流（reflow）"></a>回流（reflow）</h3><p>当页面中的某个地方发生了变化而影响了布局，此时浏览器就要重新渲染布局发生了变化的这部分区域，这个过程称为回流。<strong>回流应尽量避免，这是导致DOM脚本执行低效的关键因素之一</strong>，页面上任何一个结点触发reflow，都会导致它的子结点及祖先结点重新渲染。</p><p>能引发回流的情况：</p><blockquote><ol><li>改变窗口大小</li><li>改变文字大小</li><li>添加、删除样式表</li><li>内容的改变，如用户在输入框敲字</li><li>激活伪类</li><li>操作class属性</li><li>脚本操作DOM</li><li>计算 offsetWidth 和 offsetHeight</li><li>设置 style 属性</li></ol></blockquote><p>回流是不可避免的，只能将回流对性能的影响降到最小：</p><blockquote><ol><li>尽可能限制reflow的影响范围。需要改变元素的样式，不要通过父级元素影响子元素。最好直接加在子元素上。</li><li>通过设置style属性改变结点样式的话，每设置一次都会导致一次reflow。所以最好通过设置class的方式。</li><li>实现元素的动画，它的position属性应当设为fixed或absolute，这样不会影响其它元素的布局。</li><li>权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。</li><li>不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</li><li>很多情况下都会触发reflow，如果css里有expression，每次都会重新计算一遍。</li><li>减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。</li><li>避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。</li></ol></blockquote><h3 id="重绘（repaint）"><a href="#重绘（repaint）" class="headerlink" title="重绘（repaint）"></a>重绘（repaint）</h3><p>如果只是改变某个元素的<strong>背景色、文字颜色、边框颜色</strong>等等不影响它周围或内部布局的属性，将只会引起浏览器重绘。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/Peng2014/p/4687218.html">浏览器渲染页面原理</a></li><li><a href="https://github.com/ljianshu/Blog/issues/24#">从URL输入到页面展现到底发生什么？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vuex简单整理</title>
    <link href="/2019/09/11/Vuex%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/"/>
    <url>/2019/09/11/Vuex%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h1><p>多个页面共享状态，<br>如仅仅是父子组件共享状态则可不用Vuex</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><blockquote><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-comment">//在 Vue 中安装插件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-comment">//新建一个 Vuex 仓库</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">state</span>:&#123;<span class="hljs-comment">/*代码片段*/</span>&#125;,<br>    <span class="hljs-attr">mutations</span>:&#123;<span class="hljs-comment">/*代码片段*/</span>&#125;,<br>    <span class="hljs-attr">actions</span>:&#123;<span class="hljs-comment">/*代码片段*/</span>&#125;,<br>    <span class="hljs-attr">getters</span>:&#123;<span class="hljs-comment">/*代码片段*/</span>&#125;,<br>    <span class="hljs-attr">modules</span>:&#123;<span class="hljs-comment">/*代码片段*/</span>&#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br></code></pre></td></tr></table></figure></blockquote><h1 id="Vuex-Store-中属性的说明"><a href="#Vuex-Store-中属性的说明" class="headerlink" title="Vuex.Store 中属性的说明"></a>Vuex.Store 中属性的说明</h1><h2 id="state"><a href="#state" class="headerlink" title="state:"></a>state:</h2><blockquote><p>用于保管全局需要使用到的状态（属性）值<br><strong>注意：</strong>如果需要修改这里的值，那么只能通过 mutations 中的方法进行修改<br>虽然也可以直接用 $store.state.counter &#x3D; xxx 的方式修改，但是不推荐。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">state</span>:&#123;<br>        <span class="hljs-attr">counter</span>:<span class="hljs-number">100</span>,<br>        <span class="hljs-comment">//...</span><br>    &#125;,<br>    <span class="hljs-comment">//......</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h2><blockquote><p>定义一些方法，用于修改 state 中的状态<br>定义方法：<br>        ‘事件类型 ‘：回调函数<br>        ‘increment ‘: function(){…}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js">   <span class="hljs-attr">mutations</span>:&#123;<br>       <span class="hljs-comment">//定义一个 increment 方法，用来将state中的数据 +1</span><br>       <span class="hljs-string">&#x27;increment&#x27;</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">state</span>)&#123;<br>           state.<span class="hljs-property">counter</span>++<br>       &#125;,<br>       <span class="hljs-comment">/* 简写如下：</span><br><span class="hljs-comment">       increment(state)&#123;</span><br><span class="hljs-comment">           state.counter++</span><br><span class="hljs-comment">       &#125;</span><br><span class="hljs-comment">       */</span>,<br>       <span class="hljs-comment">//mutations 中的方法接收传递的参数作为第二个参数</span><br>       <span class="hljs-title function_">incrementCount</span>(<span class="hljs-params">state,count</span>)&#123;<br>           state.<span class="hljs-property">counter</span> += count<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-comment">//在组件中如何触发这个方法：</span><br>   <span class="hljs-attr">methods</span>:&#123;<br>       <span class="hljs-comment">//当组件中触发了add方法，那么就会触发Store中数据的更新</span><br>       <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>       &#125;,<br>       <span class="hljs-title function_">addCount</span>(<span class="hljs-params">count</span>)&#123;<br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;incrementCount&#x27;</span>,count)<br>           <span class="hljs-comment">//如果需要传递的参数过多</span><br>           <span class="hljs-comment">//则需要将这些参数包装为一个对象再进行传递 Payload</span><br>       &#125;<br>   &#125;<br><br><span class="hljs-comment">// commit 的另外一种使用方法</span><br><span class="hljs-comment">// 以这种方式触发的 mutation 方法中获取到的参数稍有不同</span><br>       $store.<span class="hljs-title function_">commit</span>(&#123;<br>           <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;increment&#x27;</span>,<br>           &#123;<span class="hljs-comment">/*参数对象*/</span>&#125;<br>       &#125;)<br></code></pre></td></tr></table></figure></blockquote><h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2><p>类似于 Vue 中的计算属性</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">getters</span>:&#123;<br>    <span class="hljs-comment">//定义一个power方法，返回 state 中的 couter 属性值的平方</span><br>    <span class="hljs-title function_">power</span>(<span class="hljs-params">state</span>)&#123;<br>        <span class="hljs-keyword">return</span> state.<span class="hljs-property">counter</span> * state.<span class="hljs-property">counter</span><br>    &#125;,<br>    <span class="hljs-comment">//getters 中的函数接受第二个参数为 getters</span><br>    <span class="hljs-title function_">powerType</span>(<span class="hljs-params">state,getters</span>)&#123;<br>        <span class="hljs-comment">//返回 power 的数据类型</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> getters.<span class="hljs-property">power</span><br>    &#125;,<br>    <span class="hljs-comment">//如果要想向 getters 中的函数传递参数的话，则可以让这个函数返回另一个函数，但是此类 getters 的结果不会被缓存</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    在组件中的使用：</span><br><span class="hljs-comment">    $store.getters.powerNum(10)</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-title function_">powerNum</span>(<span class="hljs-params">state,getters</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> state.<span class="hljs-property">counter</span> * num<br>        &#125;<br>    &#125;,<br>&#125;<br><br><span class="hljs-comment">/*组件中如何获取 getters 中的数据：</span><br><span class="hljs-comment">$store.getters.power</span><br><span class="hljs-comment">或者</span><br><span class="hljs-comment">$store.getters[&#x27;power&#x27;]</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure></blockquote><h2 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h2><p>类似于 mutations ，只不过用来代替 mutations 来执行异步操作</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">actions</span>:&#123;<br>    <span class="hljs-comment">//actions 中的函数接收 context 作为第一个参数，意为上下文</span><br>    <span class="hljs-comment">//第二个参数为携带的数据</span><br>    <span class="hljs-title function_">asyncFunc</span>(<span class="hljs-params">context，payload</span>)&#123;<br>        <span class="hljs-comment">//在这里不能直接修改 state 中的数据</span><br>        <span class="hljs-comment">//而是要通过调用 mutation 进行修改</span><br>        <span class="hljs-title function_">setTimeOut</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;power&#x27;</span>)<br>        &#125;,<span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>用于将 store 分为各个小的模块</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">modules</span>:&#123;<br>    <span class="hljs-attr">moduleA</span>:&#123;<br>        <span class="hljs-attr">state</span>:&#123;&#125;,<br>        <span class="hljs-attr">getters</span>:&#123;<br>            <span class="hljs-comment">/*模块中的getters的前三个参数分别是：</span><br><span class="hljs-comment">            state（本模块中的的状态）</span><br><span class="hljs-comment">            getters（本模块中的getters）</span><br><span class="hljs-comment">            rootstate（父级模块中的状态）</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-title function_">test</span>(<span class="hljs-params">state，getters，rootstate</span>)&#123;<br>                <span class="hljs-comment">//...</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">mutations</span>:&#123;&#125;,<br>        <span class="hljs-attr">actions</span>:&#123;<br>            <span class="hljs-title function_">testAction</span>(<span class="hljs-params">context</span>)&#123;<br>                context.<span class="hljs-property">state</span><span class="hljs-comment">//访问模块内状态</span><br>                context.<span class="hljs-title function_">commit</span>()<span class="hljs-comment">//访问模块内mutations</span><br>                context.<span class="hljs-property">rootstate</span><span class="hljs-comment">//访问根模块内状态</span><br>            &#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">modulesB</span>:&#123;<br>        <span class="hljs-attr">state</span>:&#123;&#125;,<br>        <span class="hljs-attr">getters</span>:&#123;&#125;,<br>        <span class="hljs-attr">mutations</span>:&#123;&#125;,<br>        <span class="hljs-attr">actions</span>:&#123;&#125;<br>    &#125;,<br>    <span class="hljs-comment">//....</span><br>&#125;<br><br><span class="hljs-comment">//访问模块中的状态</span><br>$store.<span class="hljs-property">state</span>.<span class="hljs-property">moduleA</span>.<span class="hljs-property">name</span><span class="hljs-comment">//获取到模块A中state中的name属性</span><br>$store.<span class="hljs-property">state</span>.<span class="hljs-property">moduleA</span>.<span class="hljs-property">name</span><span class="hljs-comment">//获取到模块B中state中的name属性</span><br><br><span class="hljs-comment">//访问模块中的getters</span><br><br><span class="hljs-comment">//调用模块中的mutations</span><br>$store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;type&#x27;</span>,payload)<span class="hljs-comment">//</span><br><br><span class="hljs-comment">//调用模块中的actions</span><br>$store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;type&#x27;</span>)<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="Vuex-数据响应式原理"><a href="#Vuex-数据响应式原理" class="headerlink" title="Vuex 数据响应式原理"></a>Vuex 数据响应式原理</h1><p><strong>vuex 只会将已经在 state 中初始化好的数据进行响应式地渲染</strong>  </p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//例子：</span><br><span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">state</span>:&#123;<br>        <span class="hljs-attr">one</span>:<span class="hljs-string">&#x27;one&#x27;</span>,<br>        <span class="hljs-attr">two</span>:&#123;<br>            <span class="hljs-attr">two_1</span>:<span class="hljs-string">&#x27;two_1&#x27;</span>,<br>            <span class="hljs-attr">two_2</span>:<span class="hljs-string">&#x27;two_2&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//上面定义地属性 one two 都会被添加到 Vuex 的响应式系统中，值一但发生变化，页面上的数据也会随之变化</span><br><br><span class="hljs-comment">//如果通过 mutations 的方法往 state 中添加一个从未拥有的数据，则页面不会将新的数据渲染出来</span><br><span class="hljs-comment">//如果突然将 state 中的某个数据删除掉，页面也不会实时将数据删除掉</span><br><span class="hljs-attr">mutations</span>:&#123;<br>    <span class="hljs-title function_">update</span>(<span class="hljs-params">state</span>)&#123;<br>        <span class="hljs-comment">//添加一条新的数据，页面不会实时显示出来</span><br>        state.<span class="hljs-property">three</span> = <span class="hljs-string">&#x27;three&#x27;</span><br>        <br>        <span class="hljs-comment">//如果需要实时更新页面，则需要用如下方式添加</span><br>        <span class="hljs-comment">//Vue.set(需要更新的数据对象，键名或数组下标，值)</span><br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">set</span>(state,<span class="hljs-string">&#x27;three&#x27;</span>,<span class="hljs-string">&#x27;three&#x27;</span>)<br>        <br>        <span class="hljs-comment">//删除一条数据,页面任然显示该数据</span><br>        <span class="hljs-keyword">delete</span> state.<span class="hljs-property">one</span><br>        <span class="hljs-comment">//如果需要实时更新页面，则需要用如下方式删除</span><br>        <span class="hljs-comment">//Vue.delete(需要删除数据的数据对象，键名或数组下标)</span><br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">delete</span>(state,<span class="hljs-string">&#x27;one&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Vuex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios简单整理</title>
    <link href="/2019/09/11/axios%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/"/>
    <url>/2019/09/11/axios%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><ul><li><p>axios(config)</p></li><li><p>axios.request(config)</p></li><li><p>axios.get(url[,config])</p></li><li><p>axios.delete(url[,config])</p></li><li><p>axios.head(url[,config])</p></li><li><p>axios.post(url[,data[,config]])</p></li><li><p>axios.put(url[,data[,config]])</p></li><li><p>axios.patch(url[,data[,config]])</p></li></ul><h2 id="axios-config"><a href="#axios-config" class="headerlink" title="axios(config)"></a>axios(config)</h2><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://xxxxx.xxx&#x27;</span>,<br>    <span class="hljs-attr">method</span>:<span class="hljs-string">&quot;get/post/...&quot;</span>,<br>    <span class="hljs-attr">params</span>:&#123;<br>        <span class="hljs-attr">key1</span>:value1,<br>        <span class="hljs-attr">key2</span>:value2,<br>        <span class="hljs-comment">//...</span><br>    &#125;,<br>    <span class="hljs-attr">timeout</span>:<span class="hljs-number">1000</span>,<span class="hljs-comment">//超时时间 ms</span><br>    <br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//成功代码</span><br>&#125;).<span class="hljs-title function_">catch</span>( <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//失败代码</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="axios-get-url-config"><a href="#axios-get-url-config" class="headerlink" title="axios.get(url[,config])"></a>axios.get(url[,config])</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://xxxxx.xxx&#x27;</span>,&#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="axios-发送并发请求"><a href="#axios-发送并发请求" class="headerlink" title="axios 发送并发请求"></a>axios 发送并发请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">all</span>([<br>    <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;),<br>    <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;)<br>]).<span class="hljs-title function_">then</span>( axios.<span class="hljs-title function_">spread</span>(<span class="hljs-function">(<span class="hljs-params">res1, res2</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//res1为第一个请求返回的数据</span><br>    <span class="hljs-comment">//res2为第二个请求返回的数据</span><br>    <span class="hljs-comment">//请求都返回结果后才执行这里的代码</span><br>&#125;)).<span class="hljs-title function_">catch</span>( <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="axios-全局配置"><a href="#axios-全局配置" class="headerlink" title="axios 全局配置"></a>axios 全局配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//全局配置会自动添加到每个 axios 请求的配置信息中</span><br><span class="hljs-comment">//常用全局配置信息：</span><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&#x27;xxxx&#x27;</span><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">timeout</span> = <span class="hljs-number">1000</span><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">methods</span> = <span class="hljs-string">&#x27;get&#x27;</span><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">headers</span> = &#123;<br>    <span class="hljs-string">&#x27;content-type&#x27;</span>:<span class="hljs-string">&#x27;application/json&#x27;</span>,<br>    <span class="hljs-comment">//...</span><br>&#125;<br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">params</span> = &#123;<br>    <span class="hljs-comment">//查询对象</span><br>&#125;<br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">transformRequest</span> = [<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br> <span class="hljs-comment">//向服务器发送前，修改请求数据</span><br>    <span class="hljs-comment">//必须返回字符串</span><br>    <span class="hljs-comment">//只能用在 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span><br>    <span class="hljs-keyword">return</span> data<br>&#125;]<br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">transformResponse</span> = [<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//在传递给 then/catch 前，允许修改响应数据</span><br>    <span class="hljs-comment">//对data进行任意处理</span><br>    <span class="hljs-keyword">return</span> data<br>&#125;]<br></code></pre></td></tr></table></figure><h2 id="axios创建实例"><a href="#axios创建实例" class="headerlink" title="axios创建实例"></a>axios创建实例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> test = axios.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-comment">//一些实例通用配置</span><br>    <span class="hljs-attr">baseURL</span>:<span class="hljs-string">&#x27;http://111.222.33.44:80&#x27;</span>,<br>    <span class="hljs-attr">timeout</span>:<span class="hljs-number">5000</span><br>&#125;)<br><br><span class="hljs-comment">//使用实例</span><br><span class="hljs-title function_">test</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-comment">//其他配置</span><br>&#125;).<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;).<span class="hljs-title function_">catch</span>( <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="axios-拦截器"><a href="#axios-拦截器" class="headerlink" title="axios 拦截器"></a>axios 拦截器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//全局请求拦截</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>( <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//拦截成功发送前的请求</span><br>    <br>    <span class="hljs-comment">//1.对请求的 config 信息做一些处理</span><br>    <span class="hljs-comment">//2.在请求时对某些页面做一些处理</span><br>    <br>    <span class="hljs-comment">//最后一定要把 config 返回，否则发送的请求拿不到该配置信息</span><br>    <span class="hljs-keyword">return</span> config<br>&#125;,<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//拦截发送失败的请求，网络原因</span><br>&#125;)<br><span class="hljs-comment">//某个实例请求拦截</span><br>实例名.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-comment">/*代码同上*/</span>)<br><br><br><br><span class="hljs-comment">//全局响应拦截</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>( <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//拦截成功响应结果</span><br>    <br>    <span class="hljs-comment">//处理完响应数据后必须将结果返回，否则发送的请求拿不到数据</span><br>    <span class="hljs-keyword">return</span> res<br>&#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//拦截失败响应结果</span><br>&#125;)<br><span class="hljs-comment">//某个实例响应拦截</span><br>实例名.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-comment">/*代码同上*/</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7环境下nginx服务器的搭建</title>
    <link href="/2019/09/11/CentOS7%E7%8E%AF%E5%A2%83%E4%B8%8Bnginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/09/11/CentOS7%E7%8E%AF%E5%A2%83%E4%B8%8Bnginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx安装准备"><a href="#Nginx安装准备" class="headerlink" title="Nginx安装准备"></a>Nginx安装准备</h1><h2 id="安装make"><a href="#安装make" class="headerlink" title="安装make"></a>安装make</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">yum -y install gcc automake autoconf libtool make<br></code></pre></td></tr></table></figure></blockquote><h2 id="安装g"><a href="#安装g" class="headerlink" title="安装g++"></a>安装g++</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install gcc gcc-c++<br></code></pre></td></tr></table></figure></blockquote><h2 id="安装PCRE库"><a href="#安装PCRE库" class="headerlink" title="安装PCRE库"></a>安装PCRE库</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.43.tar.gz<br><br>tar -zxvf pcre-8.43.tar.gz<br><span class="hljs-built_in">cd</span> pcre-8.43<br>./configure<br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure></blockquote><h2 id="安装zlib库"><a href="#安装zlib库" class="headerlink" title="安装zlib库"></a>安装zlib库</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://zlib.net/zlib-1.2.11.tar.gz<br>tar -zxvf zlib-1.2.11.tar.gz<br><span class="hljs-built_in">cd</span> zlib-1.2.11<br>./configure<br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure></blockquote><h2 id="安装ssl"><a href="#安装ssl" class="headerlink" title="安装ssl"></a>安装ssl</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://www.openssl.org/source/openssl-1.1.1c.tar.gz<br>tar -zxvf openssl-1.0.1t.tar.gz<br>//无后续操作<br></code></pre></td></tr></table></figure></blockquote><h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;wget http://nginx.org/download/nginx-1.16.0.tar.gz<br>&gt;tar -zxvf nginx-1.16.0.tar.gz<br>&gt;<span class="hljs-built_in">cd</span> nginx-1.16.0<br><br>&gt;./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-pcre=/usr/local/nginx_src/pcre-8.43 --with-zlib=/usr/local/nginx_src/zlib-1.2.11 --with-openssl=/usr/local/nginx_src/openssl-1.1.1c<br><br>&gt;make &amp;&amp; make install<br></code></pre></td></tr></table></figure></blockquote><h2 id="将Nginx注册为服务随系统启动"><a href="#将Nginx注册为服务随系统启动" class="headerlink" title="将Nginx注册为服务随系统启动"></a>将Nginx注册为服务随系统启动</h2><h3 id="创建服务文件"><a href="#创建服务文件" class="headerlink" title="创建服务文件"></a>创建服务文件</h3><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /lib/systemd/system/nginx.service<br></code></pre></td></tr></table></figure></blockquote><h3 id="在nginx-service中写入以下内容"><a href="#在nginx-service中写入以下内容" class="headerlink" title="在nginx.service中写入以下内容"></a>在nginx.service中写入以下内容</h3><blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=nginx service<br><span class="hljs-attr">After</span>=network.target <br><br><span class="hljs-section">[Service]</span> <br><span class="hljs-attr">Type</span>=forking <br><span class="hljs-attr">ExecStart</span>=/usr/local/nginx/sbin/nginx<br><span class="hljs-attr">ExecReload</span>=/usr/local/nginx/sbin/nginx -s reload<br><span class="hljs-attr">ExecStop</span>=/usr/local/nginx/sbin/nginx -s quit<br><span class="hljs-attr">PrivateTmp</span>=<span class="hljs-literal">true</span> <br>   <br><span class="hljs-section">[Install]</span> <br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure></blockquote><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><blockquote><p><strong>service nginx start    启动服务</strong></p><p><strong>service nginx stop    关闭服务</strong></p><p><strong>service nginx reload    重启服务</strong></p><p>systemctl start nginx.service　         启动nginx服务<br>systemctl stop nginx.service　          停止服务<br>systemctl restart nginx.service　       重新启动服务<br>systemctl list-units –type&#x3D;service     查看所有已启动的服务<br>systemctl status nginx.service          查看服务当前状态<br>systemctl enable nginx.service          设置开机自启动<br>systemctl disable nginx.service         停止开机自启动</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>服务器</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建完成</title>
    <link href="/2019/09/11/first/"/>
    <url>/2019/09/11/first/</url>
    
    <content type="html"><![CDATA[<p>弄了有一段时间了，终于在今天完成了自己的个人博客主页，写一篇博客纪念一下，嘿嘿。<br>接下来把之前写的几篇笔记搬运过来，填充一下内容。<br>今天之后又有时间好好学习了。<br><img src="https://img.52z.com/upload/201707/27/1501121556251740.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
