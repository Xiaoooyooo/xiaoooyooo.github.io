---
title: 动态规划
date: 2022-05-11 21:29:31
tags:
    - 动态规划
categories: 
    - 算法
---
# 动态规划

**动态规划**（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过**把原问题分解为相对简单的子问题**的方式求解复杂问题的方法（摘自[维基百科](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)）。

动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

## 代码实现理论

动态规划通过记忆化的方式储存子问题的结果，该方式通常是一个数组，简称**dp数组**，该数组可能是一维数组或是二维数组，其中每个索引所对应的值都有实际的意义。

利用动态规划求解一般有以下几个步骤

1. 确定dp数组索引含义；
2. 确定状态转移方程；
3. 确定初始状态；
4. 推导最终状态；

接下来利用一个简单的例子来说明以上步骤。

### 利用动态规划求解斐波那契数列

首先需要知道什么是斐波那契数列，及后一个数字的值为它前两个数字的值之和。

#### 确定dp数组含义

假设我们要求第n个数字的值，不妨大胆假设它就是`dp[n]`，即我们确定了`dp[n]`的含义就是第n个数字的值。

#### 确定状态转移方程

通过斐波那契数列的定义可知，`dp[i] = dp[i - 1] + dp[i - 2]`，该表达式即为我们需要的状态转移方程。

#### 确定初始状态

我们需要确定第一个数和第二个数，才能推断出第三个及后面的数字，因而很简单就能得知dp数组的初始状态应该为：`dp = [0, 1]`

#### 推导

首先需要一个循环：

```js
for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
}
```

为什么从2开始？因为dp数组中已经有了两个初始值，所以对于小于2的n直接返回dp[n]就行了：

```js
if (n < 2) {
    return dp[n];
}
```

最后在循环结束时返回d[n]。

最终代码如下：

```js
function Fibonacci(n) {
    const dp = new Array(n + 1).fill(null);
    dp[0] = 0;
    dp[1] = 1;
    if (n < 2) {
        return dp[n];
    }
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

这便是一个最简单的动态规划案例。