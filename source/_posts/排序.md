---
title: 排序算法
date: 2021-03-10 15:09:47
tags:
	- 算法
	- 排序算法
categories:
	- 算法
---

# 排序算法

此篇文章用于记录本人对排序算法的学习以及记录，不定期进行补充。

## 冒泡排序

冒泡排序就是在一个给定的数组中，依次比较相邻的两个数，逐渐将大（或小）的数交换到数组的一侧，整个过程就像冒泡一般，故称冒泡排序。

**理论描述**

+ 从数组的第一个元素开始，比较相邻两个数的大小，如果前一个比后一个大，则交换这两个数的位置；
+ 比较下一对相邻的数，直到数组的末尾，这一轮比较就会得出一个未排序部分中的一个最大数；
+ 针对未排序部分进行上述操作；
+ 重复以上步骤直到数组排序完成。

**动图演示**

![冒泡排序](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)

**代码实现**

```js
function bubbleSort(arr){
    //外层循环，理论上有多少个数就需要循环多少次，但最后只剩一个数字未排序时就可以不用在继续了
    for(let i = 1; i < arr.length; i++){
        //内层循环，仅在未排序的部分循环比较
        for(let j = 0; j < arr.length - i; j++){
            arr[i] > arr[i + 1] && ([[arr[i], arr[i + 1]] = [arr[i + 1], arr[i]])
        }
    }
    return arr
}
```

## 选择排序

选择排序的原理就是在数组当中的未排序的序列中进行比较，选出一个最小（或最大）的数插入到有序序列中的尾部（或头部）

**理论描述**

+ 循环开始时选取当前未排序序列的第一个为最小值，记下当前最小值的索引；
+ 将当前最小值与所遍历到的值作比较，如果当前值小于最小值，则更新最小值的索引为当前值的索引；
+ 遍历到末尾时，将最小值插入到有序序列末尾（将最小值与无序序列的第一位做交换，有序序列在数组头部）；
+ 对无序序列重复以上操作。

**动图演示**

![选择排序](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif)

**代码实现**

```js
function selectionSort(arr){
    // minIndex用于保存最小值的索引
    let minIndex
    for(let i = 0; i < arr.length - 1; i++){
        // 外层循环，开始时将第一个值默认设为最小值
        minIndex = i
        for(let j = i + 1; j < arr.length; j++){
            // 内层循环，从无序序列的第二个值开始比较
            arr[minIndex] > arr[i] && (minIndex = i)
        }
        // 将最小值与无序序列的第一项交换
        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
    }
    return arr
}
```

## 插入排序

在未排序序列中选择第一个数，将它与有序序列中的每一项从后往前依次进行比较，每次比较如果该数小于所比较的数，则交换这两个数的位置，否则说明位置正确，从无序序列中选取下一个数重复这个流程。

**理论描述**

+ 默认数组的第一个数已经是正确位置；
+ 将无序序列第一个数作为当前需要排序的数，下文简称目标数；
+ 将目标数从后之前依次与有序序列中的数作比较，如果目标数小于所比较数，则交换两数的位置；
+ 如果目标数大于所比较数，则说明目标数位置正确；
+ 重复步骤2至步骤4，直至排序完成。

**动图演示**

![插入排序](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif)

**代码实现**

```js
function insertionSort(arr){
    for(let i = 1; i < arr.length; i++){
        //外层循环，默认数组的第一个数已经在正确位置
        //从数组的第二个数开始排序
        for(let j = i; j > 0; j--){
            //内层循环，
            //如果目标数大于比较数，则说明目标数位置正确，不用再继续了
            if(arr[j] > arr[j - 1]) break
            //否则交换这两个数的位置
            [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]
        }
    }
    return arr
}
```



# 参考资料

+ [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)