---
title: 了解浏览器工作原理
date: 2019-09-21 20:16:09
#index_img: https://demos.xiaoooyooo.site/picture?tag=001
tags:
  - 浏览器
categories:
	- 浏览器
---
# 浏览器工作原理

# 了解浏览器工作原理

简单来说，浏览器的作用就是将用户输入的URL网址以图文的形式展示给用户，在网络条件良好的情况下，这个过程往往在极短的时间内发生，看似简单的流程实则比我们想象的复杂的多。

## 从用户键入URL地址到页面渲染

### 一、域名解析

1. 浏览器首先会查找自身缓存，如果有该域名记录，则直接返回IP地址；
2. 浏览器查找操作系统缓存
3. 浏览器查找路由器缓存
4. 浏览器查找ISP服务器
5. 浏览器查找根域名服务器（如.com)，进行递归查询

### 二、TCP三次握手

1. 浏览器向服务器发送一个带**SYN=1，Seq=X**的数据包到服务器
2. 服务器收到数据包，并返回一个带**SYN=1，ACK=X+1，Seq=Y**的响应包回应确认信息
3. 客户端收到响应信息再次回复一个带**ACK=Y+1，ACK=Seq=Z**的数据包，至此握手结束

**需要三次握手的原因：**为了防止已失效的连接请求报文段突然又回传到了服务器

### 三、浏览器发送HTTP请求

一次HTTP请求由**请求行**，**请求头**和**请求体**三部分组成

+ 请求行包括请求方法，URL，协议版本

  + 请求方法：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE
  + URL：scheme://host.domain:port/path/filename
  + 协议版本：即HTTP版本号

  例如：`GET /about/ HTTP/1.1`

+ 请求头由一些键值对组成

+ 请求体包含一些额外的请求参数，且并不是所有的请求都有请求体

### 四、服务器处理请求并返回信息

响应报文由**响应行**，**响应头**和**响应主体**三部分

+ 相应行包括协议版本，状态码，状态码描述
+ 响应头同请求头，由一些键值对组成
+ 响应体包含返回数据

### 五、浏览器解析并渲染页面

1. 根据HTML生成DOM树
2. 根据CSS生成CSS规则树
3. 结合DOM树和CSS规则树生成渲染树
4. 根据渲染树计算每一个节点的信息
5. 根据计算好的信息绘制页面

### 六、断开TCP连接

当浏览器与服务器双方数据都传送完毕之后便会断开TCP连接，这个过程可以理解为四次挥手

+ 发起方发送一个FIN报文**FIN=1，Seq=u**，并停止发送数据，进入**FIN_WAIT1**状态
+ 被动方收到FIN报文，并回复一条确认报文**ACK=1，确认号ack=u+1，序号seq=v**，被动方进入**CLOSE_WAIT**状态；发起方收到后进入**FIN_WAIT2**状态
+ 被动方如果准备好断开连接，便向发起方发送一条FIN报文**FIN=1，ACK=1，序号seq=w，确认号ack=u+1**，被动方进入**LAST_ACK**状态
+ 发起方收到FIN报文之后，回复一条确认报文**ACK=1，seq=u+1，ack=w+1**，发起方进入**TIME_WAIT**状态，经过**2MSL**之后，发起方进入**CLOSED**状态

## 浏览器渲染原理

（以下内容摘自[浏览器渲染页面原理](https://www.cnblogs.com/Peng2014/p/4687218.html)）

> 1. 用户输入网址（假设是个 HTML 页面，第一次访问，无缓存情况），浏览器向服务器发出HTTP请求，服务器返回 HTML 文件； **（善用缓存，减少HTTP请求，减轻服务器压力）**
>
> 2. 浏览器载入 HTML 代码，发现 head 内有一个 link 引用外部 CSS 文件,则浏览器立即发送CSS文件请求，获取浏览器返回的CSS文件；  **（CSS文件合并，减少HTTP请求）**
>
> 3. 浏览器继续载入 HTML 中 body 部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了；                              **（CSS文件需要放置最上面，避免网页重新渲染）**
> 4. 浏览器在代码中发现一个 img 标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；    **（图片文件合并，减少HTTP请求）**
>
> 5. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；   **（最好图片都设置尺寸，避免重新渲染）**
>
> 6. 浏览器发现了一个包含一行 JavaScript 代码的 script 标签，会立即运行该js代码；              **（script最好放置页面最下面）**
>
> 7. js脚本执行了语句，它令浏览器隐藏掉代码中的某个 div,突然就少了一个元素，浏览器不得不重新渲染这部分代码；   **（页面初始化样式不要使用js控制）**
>
> 8. 终于等到了 /html 的到来，浏览器泪流满面……
>
> 9. 等等，还没完，用户点了一下界面中的“换肤”按钮，JavaScript 让浏览器换了一下 link 标签的 CSS 路径；
>
> 10. 浏览器召集了在座的各位 div span ul li 们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。

## 影像页面渲染速度的主要因素——回流和重绘：

### 回流（reflow）

当页面中的某个地方发生了变化而影响了布局，此时浏览器就要重新渲染布局发生了变化的这部分区域，这个过程称为回流。**回流应尽量避免，这是导致DOM脚本执行低效的关键因素之一**，页面上任何一个结点触发reflow，都会导致它的子结点及祖先结点重新渲染。

能引发回流的情况：

> 1. 改变窗口大小
> 2. 改变文字大小
> 3. 添加、删除样式表
> 4. 内容的改变，如用户在输入框敲字
> 5. 激活伪类
> 6. 操作class属性
> 7. 脚本操作DOM
> 8. 计算 offsetWidth 和 offsetHeight
> 9. 设置 style 属性

回流是不可避免的，只能将回流对性能的影响降到最小：

> 1. 尽可能限制reflow的影响范围。需要改变元素的样式，不要通过父级元素影响子元素。最好直接加在子元素上。
> 2. 通过设置style属性改变结点样式的话，每设置一次都会导致一次reflow。所以最好通过设置class的方式。
> 3. 实现元素的动画，它的position属性应当设为fixed或absolute，这样不会影响其它元素的布局。
> 4. 权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。
> 5. 不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。
> 6. 很多情况下都会触发reflow，如果css里有expression，每次都会重新计算一遍。
> 7. 减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。
> 8. 避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。

### 重绘（repaint）

如果只是改变某个元素的**背景色、文字颜色、边框颜色**等等不影响它周围或内部布局的属性，将只会引起浏览器重绘。

## 参考

+ [浏览器渲染页面原理](https://www.cnblogs.com/Peng2014/p/4687218.html)
+ [从URL输入到页面展现到底发生什么？](https://github.com/ljianshu/Blog/issues/24#)